{
  "language": "Solidity",
  "sources": {
    "src/Interfaces/IBondCalculator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity >=0.7.5 <=0.8.10;\n\ninterface IBondCalculator {\n    function valuation(address tokenIn, uint256 amount_) external view returns (uint256 amountOut);\n}\n"
    },
    "src/Types/TheopetraAccessControlled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport \"../Interfaces/ITheopetraAuthority.sol\";\n\nabstract contract TheopetraAccessControlled {\n    /* ========== EVENTS ========== */\n\n    event AuthorityUpdated(ITheopetraAuthority indexed authority);\n\n    string constant UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\n\n    /* ========== STATE VARIABLES ========== */\n\n    ITheopetraAuthority public authority;\n\n    /* ========== Constructor ========== */\n\n    constructor(ITheopetraAuthority _authority) {\n        authority = _authority;\n        emit AuthorityUpdated(_authority);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyGovernor() {\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyGuardian() {\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyPolicy() {\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == authority.manager(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\n        _;\n    }\n\n    /* ========== GOV ONLY ========== */\n\n    function setAuthority(ITheopetraAuthority _newAuthority) external onlyGovernor {\n        authority = _newAuthority;\n        emit AuthorityUpdated(_newAuthority);\n    }\n}\n"
    },
    "src/Interfaces/ITheopetraAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface ITheopetraAuthority {\n    /* ========== EVENTS ========== */\n\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event ManagerPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event SignerPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n\n    event GovernorPulled(address indexed from, address indexed to);\n    event GuardianPulled(address indexed from, address indexed to);\n    event PolicyPulled(address indexed from, address indexed to);\n    event ManagerPulled(address indexed from, address indexed to);\n    event VaultPulled(address indexed from, address indexed to);\n    event SignerPulled(address indexed from, address indexed to);\n\n    /* ========== VIEW ========== */\n\n    function governor() external view returns (address);\n\n    function guardian() external view returns (address);\n\n    function policy() external view returns (address);\n\n    function manager() external view returns (address);\n\n    function vault() external view returns (address);\n\n    function whitelistSigner() external view returns (address);\n}\n"
    },
    "src/Theopetra/TheopetraYieldReporter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"../Types/TheopetraAccessControlled.sol\";\nimport \"../Interfaces/IYieldReporter.sol\";\n\n/**\n * @title Theopetra Yield Reorter\n * @notice\n */\n\ncontract TheopetraYieldReporter is IYieldReporter, TheopetraAccessControlled {\n    /* ======== STATE VARIABLES ======== */\n\n    /**\n     * @notice Theopetra reported yields by index\n     */\n    mapping(uint256 => int256) private yields;\n    /**\n     * @notice current yield ID\n     */\n    uint256 private currentIndex = 0;\n\n    /* ======== CONSTANTS ======== */\n\n    string private constant OUT_OF_BOUNDS = \"OUT_OF_BOUNDS\";\n\n    /* ======== CONSTRUCTOR ======== */\n\n    constructor(ITheopetraAuthority _authority) TheopetraAccessControlled(_authority) {\n        // initialize yield 0 to 0\n        yields[currentIndex] = 0;\n    }\n\n    /**\n     * @notice return the number of decimals expect in the fixed point yield representation (9)\n     * @return uint256  number of decimals (9)\n     */\n    function decimals() external pure returns (int256) {\n        return 9;\n    }\n\n    /**\n     * @notice returns the previous yield value or 0 if no previous yield\n     * @return int256  previous yield value\n     * @dev If there is only 1 yield reported, the current yield is returned\n     */\n    function lastYield() external view returns (int256) {\n        if (currentIndex == 0) return 0;\n        return currentIndex == 1 ? yields[1] : yields[currentIndex - 1];\n    }\n\n    /**\n     * @notice returns the current index value\n     * @return uint256  current index value\n     */\n    function getCurrentIndex() external view returns (uint256) {\n        return currentIndex;\n    }\n\n    /**\n     * @notice returns the current yield value\n     * @return int256  current yield value\n     */\n    function currentYield() external view returns (int256) {\n        // constructor and solidity defaults allow this to return 0 before\n        // any yields are reported\n        return yields[currentIndex];\n    }\n\n    /**\n     * @notice returns the yield value for a given index\n     * @param  _id  index of yield to return\n     * @return int256  yield value\n     * @dev reverts if id is out of bounds\n     */\n    function getYieldById(uint256 _id) external view returns (int256) {\n        // don't allow requiring a yield past the current index\n        require(_id <= currentIndex, OUT_OF_BOUNDS);\n        return yields[_id];\n    }\n\n    /**\n     * @notice reports a yield value\n     * @param  _amount  yield value to report\n     * @return uint256  index of the reported yield\n     * @dev reverts if called by a non-manager address\n     * @dev emits a ReportYield event\n     */\n    function reportYield(int256 _amount) external onlyManager returns (uint256) {\n        yields[++currentIndex] = _amount;\n        emit ReportYield(currentIndex, _amount);\n        return currentIndex;\n    }\n}\n"
    },
    "src/Interfaces/IYieldReporter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IYieldReporter {\n    event ReportYield(uint256 indexed id, int256 yield);\n\n    function lastYield() external view returns (int256);\n\n    function currentYield() external view returns (int256);\n\n    function getYieldById(uint256 id) external view returns (int256);\n\n    function reportYield(int256 _amount) external returns (uint256);\n}\n"
    },
    "src/Mocks/YieldReporterMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"../Interfaces/IYieldReporter.sol\";\n\ncontract YieldReporterMock is IYieldReporter {\n    function lastYield() external view override returns (int256) {\n        return 15_000_000_000;\n    }\n\n    function currentYield() external view override returns (int256) {\n        return 24_000_000_000;\n    }\n\n    function getYieldById(uint256 id) external view override returns (int256) {\n        return 14_000_000_000;\n    }\n\n    function reportYield(int256 _amount) external override returns (uint256) {\n        return 10;\n    }\n}\n"
    },
    "src/Interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IBondCalculator.sol\";\n\ninterface ITreasury {\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256);\n\n    function withdraw(uint256 _amount, address _token) external;\n\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\n\n    function mint(address _recipient, uint256 _amount) external;\n\n    function manage(address _token, uint256 _amount) external;\n\n    function incurDebt(uint256 amount_, address token_) external;\n\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\n\n    function tokenPerformanceUpdate() external;\n\n    function baseSupply() external view returns (uint256);\n\n    function deltaTokenPrice() external view returns (int256);\n\n    function deltaTreasuryYield() external view returns (int256);\n\n    function getTheoBondingCalculator() external view returns (IBondCalculator);\n\n    function setTheoBondingCalculator(address _theoBondingCalculator) external;\n}\n"
    },
    "src/Theopetra/StakingDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5 <=0.8.10;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\nimport \"../Types/TheopetraAccessControlled.sol\";\n\nimport \"../Libraries/SafeERC20.sol\";\nimport \"../Libraries/ABDKMathQuad.sol\";\n\nimport \"../Interfaces/ITreasury.sol\";\nimport \"../Interfaces/IERC20.sol\";\nimport \"../Interfaces/IDistributor.sol\";\n\nimport \"../Interfaces/IStaking.sol\";\nimport \"../Interfaces/IStakedTHEOToken.sol\";\n\ncontract StakingDistributor is IDistributor, TheopetraAccessControlled {\n    /* ========== DEPENDENCIES ========== */\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using SafeCast for uint256;\n\n    /* ====== VARIABLES ====== */\n\n    IERC20 private immutable THEO;\n    ITreasury private immutable treasury;\n    mapping(address => bool) private staking;\n\n    uint48 public immutable epochLength;\n\n    mapping(uint256 => Adjust) public adjustments;\n    uint256 public override bounty;\n\n    uint256 private constant rateDenominator = 1_000_000_000;\n\n    /**\n        @dev    byte representation of 1095. See also `deriveRate`.\n     */\n    bytes16 private constant n = 0x400911c0000000000000000000000000;\n    /**\n        @dev    byte representation of 1;\n     */\n    bytes16 private constant one = 0x3fff0000000000000000000000000000;\n\n    event Distribute(uint256 indexed amount, uint256 indexed rate, address recipient);\n    event BountyRetrieved(uint256 indexed amount, address indexed beneficiary);\n    event SetBounty(uint256 indexed amount);\n    event AddRecipient(address recipient, uint256 startRate, bool locked);\n    event RemoveRecipient(address recipient);\n    event SetStakingContract(address stakingContract);\n    event UpdateDRS(address recipient, int256 drs);\n    event UpdateDYS(address recipient, int256 dry);\n    /* ====== STRUCTS ====== */\n\n    /**\n        @notice information for rewards to recipients\n        @dev    Info::start is the starting rate for rewards in ten-thousandsths (2000 = 0.2%);\n                Info::drs is the Discount Rate Return Staking. The discount rate applied to the fluctuation of the token price, as a proportion (that is, a percentage in its decimal form), with 9 decimals\n                Info::dys is the discount rate applied to the fluctuation of the treasury yield, as a proportion (that is, a percentage in its decimal form), with 9 decimals\n                Info::recipient is the recipient staking contract for rewards\n                Info::locked is whether the staking tranche is locked (true) or unlocked (false)\n                Info::nextEpochTime is the timestamp for the next epoch, when wind-down will next be applied to the starting reward rate and the maximum reward rate\n     */\n    struct Info {\n        uint256 start;\n        int256 drs;\n        int256 dys;\n        address recipient;\n        bool locked;\n        uint48 nextEpochTime;\n    }\n    Info[] public info;\n\n    struct Adjust {\n        bool add;\n        uint256 rate;\n        uint256 target;\n    }\n\n    /* ====== CONSTRUCTOR ====== */\n\n    constructor(\n        address _treasury,\n        address _theo,\n        uint48 _epochLength,\n        ITheopetraAuthority _authority,\n        address _staking\n    ) TheopetraAccessControlled(ITheopetraAuthority(_authority)) {\n        require(_treasury != address(0), \"Zero address: Treasury\");\n        treasury = ITreasury(_treasury);\n        require(_theo != address(0), \"Zero address: THEO\");\n        THEO = IERC20(_theo);\n        require(_staking != address(0), \"Zero address: Staking\");\n        staking[_staking] = true;\n        epochLength = _epochLength;\n    }\n\n    /* ====== Modifiers ====== */\n    modifier onlyStaking() {\n        require(staking[msg.sender], \"Only staking\");\n        _;\n    }\n\n    /* ====== PUBLIC FUNCTIONS ====== */\n\n    /**\n        @notice send epoch reward to staking contract\n        @dev    distribute can only be called by a Staking contract (and the Staking contract will only call if its epoch is over)\n                This method distributes rewards to each recipient (minting and sending from the treasury)\n                If the current time is greater than `nextEpochTime`, the starting rate is wound-down, and the `nextEpochTime` is updated.\n                Wind-down occurs according to the schedules for unlocked and locked tranches where:\n                Locked tranches wind-down by 1.5% per epoch (that is, per year) to a minimum of 6% (60_000_000 -- see also `rateDenominator`)\n                Unlocked tranches wind-down by 0.5% per epoch (that is, per year) to a minimum of 2% (20_000_000)\n     */\n    function distribute() external override onlyStaking {\n        for (uint256 i = 0; i < info.length; i++) {\n            uint256 _rate = nextRewardRate(i);\n            if (_rate > 0) {\n                uint256 reward = nextRewardAt(_rate, info[i].recipient);\n                ITreasury(treasury).mint(info[i].recipient, reward);\n                emit Distribute(reward, _rate, info[i].recipient);\n            }\n            if (info[i].nextEpochTime <= block.timestamp) {\n                if (info[i].locked == false && info[i].start > 20_000_000) {\n                    info[i].start = info[i].start.sub(5_000_000);\n                } else if (info[i].locked == true && info[i].start > 60_000_000) {\n                    info[i].start = info[i].start.sub(15_000_000);\n                }\n                info[i].nextEpochTime = uint48(uint256(info[i].nextEpochTime).add(uint256(epochLength)));\n            }\n        }\n    }\n\n    /**\n        @dev If the distributor bounty is > 0, mint it for the staking contract.\n     */\n    function retrieveBounty() external override onlyStaking returns (uint256) {\n        // onlyStaking compares msg.sender to the `staking` mapping, so this is safe\n        // msg.sender at this point can only be a staking contract\n        if (bounty > 0) {\n            treasury.mint(address(msg.sender), bounty);\n            emit BountyRetrieved(bounty, address(msg.sender));\n        }\n\n        return bounty;\n    }\n\n    /* ====== VIEW FUNCTIONS ====== */\n\n    /**\n        @notice view function for next reward at given rate\n        @param _rate uint\n        @return uint\n     */\n    function nextRewardAt(uint256 _rate, address _recipient) public view override returns (uint256) {\n        return IStakedTHEOToken(IStaking(_recipient).basis()).circulatingSupply().mul(_rate).div(rateDenominator);\n    }\n\n    /**\n        @notice view function for next reward for specified address\n        @param _recipient address\n        @return uint256\n     */\n    function nextRewardFor(address _recipient) external view override returns (uint256) {\n        uint256 reward;\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].recipient == _recipient) {\n                reward = nextRewardAt(nextRewardRate(i), _recipient);\n                break;\n            }\n        }\n        return reward;\n    }\n\n    /**\n     * @notice calculate the next reward rate\n       @dev `apyVariable`, is calculated as: APYfixed + SCrs + SCys\n            Where APYfixed is the fixed starting rate, with 9 decimals\n            SCrs is the Control Return for Staking (with 9 decimals): SCrs = Drs * deltaTokenPrice\n            SCys is Control Treasury for Staking (with 9 decimals): SCys = Dys * deltaTreasuryYield\n            The returned rate is limited to a minimum of zero and a maximum of 1.5 times the fixed starting rate (in locked and unlocked tranches).\n     * @param _index uint256\n     * @return uint256 The reward rate. 9 decimals\n     */\n    function nextRewardRate(uint256 _index) public view override returns (uint256) {\n        int256 apyVariable = (info[_index].start.toInt256())\n            .add((ITreasury(treasury).deltaTokenPrice().mul(info[_index].drs)).div(10**9))\n            .add((ITreasury(treasury).deltaTreasuryYield().mul(info[_index].dys)).div(10**9));\n\n        if (apyVariable > 0) {\n            uint256 _rate = deriveRate(uint256(apyVariable));\n            uint256 maxRate = (info[_index].start * 15) / 10;\n            return _rate < maxRate ? _rate : maxRate;\n        } else {\n            return 0;\n        }\n    }\n\n    /* ====== POLICY FUNCTIONS ====== */\n\n    /**\n     * @notice set bounty to incentivize keepers\n     * @param _bounty uint256\n     */\n    function setBounty(uint256 _bounty) external override onlyGovernor {\n        require(_bounty <= 2e9, \"Too much\");\n        bounty = _bounty;\n        emit SetBounty(_bounty);\n    }\n\n    /**\n        @notice adds recipient for distributions\n        @dev    When a recipient is added, the epochLength and current block timestamp is used to calculate when the next epoch should occur\n        @param _recipient address\n        @param _startRate uint256 9 decimal starting rate\n        @param _drs       uint256 9 decimal Discount Rate Return Staking. The discount rate applied to the fluctuation of the token price, as a proportion (that is, a percentage in its decimal form), with 9 decimals\n        @param _dys       uint256 9 decimial discount rate applied to the fluctuation of the treasury yield, as a proportion (that is, a percentage in its decimal form), with 9 decimals\n        @param _locked    bool is the staking tranche locked or unlocked\n     */\n    function addRecipient(\n        address _recipient,\n        uint256 _startRate,\n        int256 _drs,\n        int256 _dys,\n        bool _locked\n    ) external override onlyGovernor {\n        require(_recipient != address(0), \"Recipient cannot be the zero address\");\n        require(_startRate <= rateDenominator, \"Rate cannot exceed denominator\");\n\n        info.push(\n            Info({\n                recipient: _recipient,\n                start: _startRate,\n                drs: _drs,\n                dys: _dys,\n                locked: _locked,\n                nextEpochTime: uint48((block.timestamp).add(uint256(epochLength)))\n            })\n        );\n\n        emit AddRecipient(\n            _recipient,\n            _startRate,\n            _locked\n        );\n    }\n\n    /**\n        @notice set the address as a staking contract\n        @dev setting the address as a staking contract will allow the staking contract to call the `distribute` function\n             the contract must also be set up as a recipient to receive the rewards\n        @param _addr address\n     */\n    function setStaking(address _addr) external override onlyGovernor {\n        staking[_addr] = true;\n        emit SetStakingContract(_addr);\n    }\n\n    /**\n        @notice removes recipient for distributions\n        @param _index uint\n     */\n    function removeRecipient(uint256 _index) external override {\n        require(\n            msg.sender == authority.governor() || msg.sender == authority.guardian(),\n            \"Caller is not governor or guardian\"\n        );\n        require(info[_index].recipient != address(0), \"Recipient does not exist\");\n        info[_index].recipient = address(0);\n        info[_index].start = 0;\n        info[_index].drs = 0;\n        info[_index].dys = 0;\n        emit RemoveRecipient(info[_index].recipient);\n    }\n\n    function setDiscountRateStaking(uint256 _index, int256 _drs) external override onlyPolicy {\n        info[_index].drs = _drs;\n        emit UpdateDRS(info[_index].recipient, _drs);\n    }\n\n    function setDiscountRateYield(uint256 _index, int256 _dys) external override onlyPolicy {\n        info[_index].dys = _dys;\n        emit UpdateDYS(info[_index].recipient, _dys);\n    }\n\n    /**\n     * @notice derives the rate for a given apy for the next Epoch.\n     * @dev    the rate is calculated as:\n     *         1095 * e^z - 1095\n     *         z = ln(apyProportion + 1) / 1095\n     *         1095 is: 365(days) * 24(hours) / 8(hours per performance update)\n     *         apyProportion is a proportion (that is, a percentage in its decimal form), calculated using the param _apy\n     *         0x401cdcd6500000000000000000000000 is the byte representation of 10**9\n     * @param _apy The APY to calculate the rate for. 9 decimals\n     * @return uint256 The rate for the given APY. 9 decimals\n     */\n    function deriveRate(uint256 _apy) public view returns (uint256) {\n        bytes16 apyProportion = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_apy), 0x401cdcd6500000000000000000000000);\n        bytes16 z = ABDKMathQuad.div(ABDKMathQuad.ln(ABDKMathQuad.add(apyProportion, one)), n);\n        bytes16 eToTheZ = ABDKMathQuad.exp(z);\n\n        return\n            ABDKMathQuad.toUInt(\n                ABDKMathQuad.mul(ABDKMathQuad.sub(ABDKMathQuad.mul(n, eToTheZ), n), 0x401cdcd6500000000000000000000000)\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "src/Libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport { IERC20 } from \"../Interfaces/IERC20.sol\";\n\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\n/// Taken from Solmate\nlibrary SafeERC20 {\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        (bool success, ) = to.call{ value: amount }(new bytes(0));\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "src/Libraries/ABDKMathQuad.sol": {
      "content": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math Quad Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.8.0;\n\n/**\n * Smart contract library of mathematical functions operating with IEEE 754\n * quadruple-precision binary floating-point numbers (quadruple precision\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\n * represented by bytes16 type.\n */\nlibrary ABDKMathQuad {\n    /*\n     * 0.\n     */\n    bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\n\n    /*\n     * -0.\n     */\n    bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\n\n    /*\n     * +Infinity.\n     */\n    bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\n\n    /*\n     * -Infinity.\n     */\n    bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\n\n    /*\n     * Canonical NaN value.\n     */\n    bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\n\n    /*\n     * Error message for failed require() calls.\n     */\n    string private constant REQUIRE_ERROR = \"ABDKQuad: Mathematical operation failed\";\n\n    /**\n     * Convert signed 256-bit integer number into quadruple precision number.\n     *\n     * @param x signed 256-bit integer number\n     * @return quadruple precision number\n     */\n    function fromInt(int256 x) internal pure returns (bytes16) {\n        unchecked {\n            if (x == 0) return bytes16(0);\n            else {\n                // We rely on overflow behavior here\n                uint256 result = uint256(x > 0 ? x : -x);\n\n                uint256 msb = mostSignificantBit(result);\n                if (msb < 112) result <<= 112 - msb;\n                else if (msb > 112) result >>= msb - 112;\n\n                result = (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | ((16383 + msb) << 112);\n                if (x < 0) result |= 0x80000000000000000000000000000000;\n\n                return bytes16(uint128(result));\n            }\n        }\n    }\n\n    /**\n     * Convert quadruple precision number into signed 256-bit integer number\n     * rounding towards zero.  Revert on overflow.\n     *\n     * @param x quadruple precision number\n     * @return signed 256-bit integer number\n     */\n    function toInt(bytes16 x) internal pure returns (int256) {\n        unchecked {\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\n\n            require(exponent <= 16638, REQUIRE_ERROR); // Overflow\n            if (exponent < 16383) return 0; // Underflow\n\n            uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\n\n            if (exponent < 16495) result >>= 16495 - exponent;\n            else if (exponent > 16495) result <<= exponent - 16495;\n\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\n                // Negative\n                require(result <= 0x8000000000000000000000000000000000000000000000000000000000000000, REQUIRE_ERROR);\n                return -int256(result); // We rely on overflow behavior here\n            } else {\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n                return int256(result);\n            }\n        }\n    }\n\n    /**\n     * Convert unsigned 256-bit integer number into quadruple precision number.\n     *\n     * @param x unsigned 256-bit integer number\n     * @return quadruple precision number\n     */\n    function fromUInt(uint256 x) internal pure returns (bytes16) {\n        unchecked {\n            if (x == 0) return bytes16(0);\n            else {\n                uint256 result = x;\n\n                uint256 msb = mostSignificantBit(result);\n                if (msb < 112) result <<= 112 - msb;\n                else if (msb > 112) result >>= msb - 112;\n\n                result = (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | ((16383 + msb) << 112);\n\n                return bytes16(uint128(result));\n            }\n        }\n    }\n\n    /**\n     * Convert quadruple precision number into unsigned 256-bit integer number\n     * rounding towards zero.  Revert on underflow.  Note, that negative floating\n     * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\n     * without error, because they are rounded to zero.\n     *\n     * @param x quadruple precision number\n     * @return unsigned 256-bit integer number\n     */\n    function toUInt(bytes16 x) internal pure returns (uint256) {\n        unchecked {\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\n\n            if (exponent < 16383) return 0; // Underflow\n\n            require(uint128(x) < 0x80000000000000000000000000000000, REQUIRE_ERROR); // Negative\n\n            require(exponent <= 16638, REQUIRE_ERROR); // Overflow\n            uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\n\n            if (exponent < 16495) result >>= 16495 - exponent;\n            else if (exponent > 16495) result <<= exponent - 16495;\n\n            return result;\n        }\n    }\n\n    /**\n     * Convert signed 128.128 bit fixed point number into quadruple precision\n     * number.\n     *\n     * @param x signed 128.128 bit fixed point number\n     * @return quadruple precision number\n     */\n    function from128x128(int256 x) internal pure returns (bytes16) {\n        unchecked {\n            if (x == 0) return bytes16(0);\n            else {\n                // We rely on overflow behavior here\n                uint256 result = uint256(x > 0 ? x : -x);\n\n                uint256 msb = mostSignificantBit(result);\n                if (msb < 112) result <<= 112 - msb;\n                else if (msb > 112) result >>= msb - 112;\n\n                result = (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | ((16255 + msb) << 112);\n                if (x < 0) result |= 0x80000000000000000000000000000000;\n\n                return bytes16(uint128(result));\n            }\n        }\n    }\n\n    /**\n     * Convert quadruple precision number into signed 128.128 bit fixed point\n     * number.  Revert on overflow.\n     *\n     * @param x quadruple precision number\n     * @return signed 128.128 bit fixed point number\n     */\n    function to128x128(bytes16 x) internal pure returns (int256) {\n        unchecked {\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\n\n            require(exponent <= 16510, REQUIRE_ERROR); // Overflow\n            if (exponent < 16255) return 0; // Underflow\n\n            uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\n\n            if (exponent < 16367) result >>= 16367 - exponent;\n            else if (exponent > 16367) result <<= exponent - 16367;\n\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\n                // Negative\n                require(result <= 0x8000000000000000000000000000000000000000000000000000000000000000, REQUIRE_ERROR);\n                return -int256(result); // We rely on overflow behavior here\n            } else {\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, REQUIRE_ERROR);\n                return int256(result);\n            }\n        }\n    }\n\n    /**\n     * Convert signed 64.64 bit fixed point number into quadruple precision\n     * number.\n     *\n     * @param x signed 64.64 bit fixed point number\n     * @return quadruple precision number\n     */\n    function from64x64(int128 x) internal pure returns (bytes16) {\n        unchecked {\n            if (x == 0) return bytes16(0);\n            else {\n                // We rely on overflow behavior here\n                uint256 result = uint128(x > 0 ? x : -x);\n\n                uint256 msb = mostSignificantBit(result);\n                if (msb < 112) result <<= 112 - msb;\n                else if (msb > 112) result >>= msb - 112;\n\n                result = (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | ((16319 + msb) << 112);\n                if (x < 0) result |= 0x80000000000000000000000000000000;\n\n                return bytes16(uint128(result));\n            }\n        }\n    }\n\n    /**\n     * Convert quadruple precision number into signed 64.64 bit fixed point\n     * number.  Revert on overflow.\n     *\n     * @param x quadruple precision number\n     * @return signed 64.64 bit fixed point number\n     */\n    function to64x64(bytes16 x) internal pure returns (int128) {\n        unchecked {\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\n\n            require(exponent <= 16446, REQUIRE_ERROR); // Overflow\n            if (exponent < 16319) return 0; // Underflow\n\n            uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\n\n            if (exponent < 16431) result >>= 16431 - exponent;\n            else if (exponent > 16431) result <<= exponent - 16431;\n\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\n                // Negative\n                require(result <= 0x80000000000000000000000000000000, REQUIRE_ERROR);\n                return -int128(int256(result)); // We rely on overflow behavior here\n            } else {\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, REQUIRE_ERROR);\n                return int128(int256(result));\n            }\n        }\n    }\n\n    /**\n     * Convert octuple precision number into quadruple precision number.\n     *\n     * @param x octuple precision number\n     * @return quadruple precision number\n     */\n    function fromOctuple(bytes32 x) internal pure returns (bytes16) {\n        unchecked {\n            bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\n\n            uint256 exponent = (uint256(x) >> 236) & 0x7FFFF;\n            uint256 significand = uint256(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            if (exponent == 0x7FFFF) {\n                if (significand > 0) return NaN;\n                else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n            }\n\n            if (exponent > 278526) return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n            else if (exponent < 245649) return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\n            else if (exponent < 245761) {\n                significand =\n                    (significand | 0x100000000000000000000000000000000000000000000000000000000000) >>\n                    (245885 - exponent);\n                exponent = 0;\n            } else {\n                significand >>= 124;\n                exponent -= 245760;\n            }\n\n            uint128 result = uint128(significand | (exponent << 112));\n            if (negative) result |= 0x80000000000000000000000000000000;\n\n            return bytes16(result);\n        }\n    }\n\n    /**\n     * Convert quadruple precision number into octuple precision number.\n     *\n     * @param x quadruple precision number\n     * @return octuple precision number\n     */\n    function toOctuple(bytes16 x) internal pure returns (bytes32) {\n        unchecked {\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\n\n            uint256 result = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            if (exponent == 0x7FFF)\n                exponent = 0x7FFFF; // Infinity or NaN\n            else if (exponent == 0) {\n                if (result > 0) {\n                    uint256 msb = mostSignificantBit(result);\n                    result = (result << (236 - msb)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                    exponent = 245649 + msb;\n                }\n            } else {\n                result <<= 124;\n                exponent += 245760;\n            }\n\n            result |= exponent << 236;\n            if (uint128(x) >= 0x80000000000000000000000000000000)\n                result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n            return bytes32(result);\n        }\n    }\n\n    /**\n     * Convert double precision number into quadruple precision number.\n     *\n     * @param x double precision number\n     * @return quadruple precision number\n     */\n    function fromDouble(bytes8 x) internal pure returns (bytes16) {\n        unchecked {\n            uint256 exponent = (uint64(x) >> 52) & 0x7FF;\n\n            uint256 result = uint64(x) & 0xFFFFFFFFFFFFF;\n\n            if (exponent == 0x7FF)\n                exponent = 0x7FFF; // Infinity or NaN\n            else if (exponent == 0) {\n                if (result > 0) {\n                    uint256 msb = mostSignificantBit(result);\n                    result = (result << (112 - msb)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                    exponent = 15309 + msb;\n                }\n            } else {\n                result <<= 60;\n                exponent += 15360;\n            }\n\n            result |= exponent << 112;\n            if (x & 0x8000000000000000 > 0) result |= 0x80000000000000000000000000000000;\n\n            return bytes16(uint128(result));\n        }\n    }\n\n    /**\n     * Convert quadruple precision number into double precision number.\n     *\n     * @param x quadruple precision number\n     * @return double precision number\n     */\n    function toDouble(bytes16 x) internal pure returns (bytes8) {\n        unchecked {\n            bool negative = uint128(x) >= 0x80000000000000000000000000000000;\n\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\n            uint256 significand = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            if (exponent == 0x7FFF) {\n                if (significand > 0) return 0x7FF8000000000000;\n                // NaN\n                else\n                    return\n                        negative\n                            ? bytes8(0xFFF0000000000000) // -Infinity\n                            : bytes8(0x7FF0000000000000); // Infinity\n            }\n\n            if (exponent > 17406)\n                return\n                    negative\n                        ? bytes8(0xFFF0000000000000) // -Infinity\n                        : bytes8(0x7FF0000000000000);\n            // Infinity\n            else if (exponent < 15309)\n                return\n                    negative\n                        ? bytes8(0x8000000000000000) // -0\n                        : bytes8(0x0000000000000000);\n            // 0\n            else if (exponent < 15361) {\n                significand = (significand | 0x10000000000000000000000000000) >> (15421 - exponent);\n                exponent = 0;\n            } else {\n                significand >>= 60;\n                exponent -= 15360;\n            }\n\n            uint64 result = uint64(significand | (exponent << 52));\n            if (negative) result |= 0x8000000000000000;\n\n            return bytes8(result);\n        }\n    }\n\n    /**\n     * Test whether given quadruple precision number is NaN.\n     *\n     * @param x quadruple precision number\n     * @return true if x is NaN, false otherwise\n     */\n    function isNaN(bytes16 x) internal pure returns (bool) {\n        unchecked {\n            return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF > 0x7FFF0000000000000000000000000000;\n        }\n    }\n\n    /**\n     * Test whether given quadruple precision number is positive or negative\n     * infinity.\n     *\n     * @param x quadruple precision number\n     * @return true if x is positive or negative infinity, false otherwise\n     */\n    function isInfinity(bytes16 x) internal pure returns (bool) {\n        unchecked {\n            return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0x7FFF0000000000000000000000000000;\n        }\n    }\n\n    /**\n     * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\n     * is positive.  Note that sign (-0) is zero.  Revert if x is NaN.\n     *\n     * @param x quadruple precision number\n     * @return sign of x\n     */\n    function sign(bytes16 x) internal pure returns (int8) {\n        unchecked {\n            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            require(absoluteX <= 0x7FFF0000000000000000000000000000, REQUIRE_ERROR); // Not NaN\n\n            if (absoluteX == 0) return 0;\n            else if (uint128(x) >= 0x80000000000000000000000000000000) return -1;\n            else return 1;\n        }\n    }\n\n    /**\n     * Calculate sign (x - y).  Revert if either argument is NaN, or both\n     * arguments are infinities of the same sign.\n     *\n     * @param x quadruple precision number\n     * @param y quadruple precision number\n     * @return sign (x - y)\n     */\n    function cmp(bytes16 x, bytes16 y) internal pure returns (int8) {\n        unchecked {\n            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            require(absoluteX <= 0x7FFF0000000000000000000000000000, REQUIRE_ERROR); // Not NaN\n\n            uint128 absoluteY = uint128(y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            require(absoluteY <= 0x7FFF0000000000000000000000000000, REQUIRE_ERROR); // Not NaN\n\n            // Not infinities of the same sign\n            require(x != y || absoluteX < 0x7FFF0000000000000000000000000000, REQUIRE_ERROR);\n\n            if (x == y) return 0;\n            else {\n                bool negativeX = uint128(x) >= 0x80000000000000000000000000000000;\n                bool negativeY = uint128(y) >= 0x80000000000000000000000000000000;\n\n                if (negativeX) {\n                    if (negativeY) return absoluteX > absoluteY ? -1 : int8(1);\n                    else return -1;\n                } else {\n                    if (negativeY) return 1;\n                    else return absoluteX > absoluteY ? int8(1) : -1;\n                }\n            }\n        }\n    }\n\n    /**\n     * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\n     * anything.\n     *\n     * @param x quadruple precision number\n     * @param y quadruple precision number\n     * @return true if x equals to y, false otherwise\n     */\n    function eq(bytes16 x, bytes16 y) internal pure returns (bool) {\n        unchecked {\n            if (x == y) {\n                return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF < 0x7FFF0000000000000000000000000000;\n            } else return false;\n        }\n    }\n\n    /**\n     * Calculate x + y.  Special values behave in the following way:\n     *\n     * NaN + x = NaN for any x.\n     * Infinity + x = Infinity for any finite x.\n     * -Infinity + x = -Infinity for any finite x.\n     * Infinity + Infinity = Infinity.\n     * -Infinity + -Infinity = -Infinity.\n     * Infinity + -Infinity = -Infinity + Infinity = NaN.\n     *\n     * @param x quadruple precision number\n     * @param y quadruple precision number\n     * @return quadruple precision number\n     */\n    function add(bytes16 x, bytes16 y) internal pure returns (bytes16) {\n        unchecked {\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\n            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\n\n            if (xExponent == 0x7FFF) {\n                if (yExponent == 0x7FFF) {\n                    if (x == y) return x;\n                    else return NaN;\n                } else return x;\n            } else if (yExponent == 0x7FFF) return y;\n            else {\n                bool xSign = uint128(x) >= 0x80000000000000000000000000000000;\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (xExponent == 0) xExponent = 1;\n                else xSignifier |= 0x10000000000000000000000000000;\n\n                bool ySign = uint128(y) >= 0x80000000000000000000000000000000;\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (yExponent == 0) yExponent = 1;\n                else ySignifier |= 0x10000000000000000000000000000;\n\n                if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\n                else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\n                else {\n                    int256 delta = int256(xExponent) - int256(yExponent);\n\n                    if (xSign == ySign) {\n                        if (delta > 112) return x;\n                        else if (delta > 0) ySignifier >>= uint256(delta);\n                        else if (delta < -112) return y;\n                        else if (delta < 0) {\n                            xSignifier >>= uint256(-delta);\n                            xExponent = yExponent;\n                        }\n\n                        xSignifier += ySignifier;\n\n                        if (xSignifier >= 0x20000000000000000000000000000) {\n                            xSignifier >>= 1;\n                            xExponent += 1;\n                        }\n\n                        if (xExponent == 0x7FFF) return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n                        else {\n                            if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\n                            else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n                            return\n                                bytes16(\n                                    uint128(\n                                        (xSign ? 0x80000000000000000000000000000000 : 0) |\n                                            (xExponent << 112) |\n                                            xSignifier\n                                    )\n                                );\n                        }\n                    } else {\n                        if (delta > 0) {\n                            xSignifier <<= 1;\n                            xExponent -= 1;\n                        } else if (delta < 0) {\n                            ySignifier <<= 1;\n                            xExponent = yExponent - 1;\n                        }\n\n                        if (delta > 112) ySignifier = 1;\n                        else if (delta > 1) ySignifier = ((ySignifier - 1) >> uint256(delta - 1)) + 1;\n                        else if (delta < -112) xSignifier = 1;\n                        else if (delta < -1) xSignifier = ((xSignifier - 1) >> uint256(-delta - 1)) + 1;\n\n                        if (xSignifier >= ySignifier) xSignifier -= ySignifier;\n                        else {\n                            xSignifier = ySignifier - xSignifier;\n                            xSign = ySign;\n                        }\n\n                        if (xSignifier == 0) return POSITIVE_ZERO;\n\n                        uint256 msb = mostSignificantBit(xSignifier);\n\n                        if (msb == 113) {\n                            xSignifier = (xSignifier >> 1) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                            xExponent += 1;\n                        } else if (msb < 112) {\n                            uint256 shift = 112 - msb;\n                            if (xExponent > shift) {\n                                xSignifier = (xSignifier << shift) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                                xExponent -= shift;\n                            } else {\n                                xSignifier <<= xExponent - 1;\n                                xExponent = 0;\n                            }\n                        } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n                        if (xExponent == 0x7FFF) return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n                        else\n                            return\n                                bytes16(\n                                    uint128(\n                                        (xSign ? 0x80000000000000000000000000000000 : 0) |\n                                            (xExponent << 112) |\n                                            xSignifier\n                                    )\n                                );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculate x - y.  Special values behave in the following way:\n     *\n     * NaN - x = NaN for any x.\n     * Infinity - x = Infinity for any finite x.\n     * -Infinity - x = -Infinity for any finite x.\n     * Infinity - -Infinity = Infinity.\n     * -Infinity - Infinity = -Infinity.\n     * Infinity - Infinity = -Infinity - -Infinity = NaN.\n     *\n     * @param x quadruple precision number\n     * @param y quadruple precision number\n     * @return quadruple precision number\n     */\n    function sub(bytes16 x, bytes16 y) internal pure returns (bytes16) {\n        unchecked {\n            return add(x, y ^ 0x80000000000000000000000000000000);\n        }\n    }\n\n    /**\n     * Calculate x * y.  Special values behave in the following way:\n     *\n     * NaN * x = NaN for any x.\n     * Infinity * x = Infinity for any finite positive x.\n     * Infinity * x = -Infinity for any finite negative x.\n     * -Infinity * x = -Infinity for any finite positive x.\n     * -Infinity * x = Infinity for any finite negative x.\n     * Infinity * 0 = NaN.\n     * -Infinity * 0 = NaN.\n     * Infinity * Infinity = Infinity.\n     * Infinity * -Infinity = -Infinity.\n     * -Infinity * Infinity = -Infinity.\n     * -Infinity * -Infinity = Infinity.\n     *\n     * @param x quadruple precision number\n     * @param y quadruple precision number\n     * @return quadruple precision number\n     */\n    function mul(bytes16 x, bytes16 y) internal pure returns (bytes16) {\n        unchecked {\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\n            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\n\n            if (xExponent == 0x7FFF) {\n                if (yExponent == 0x7FFF) {\n                    if (x == y) return x ^ (y & 0x80000000000000000000000000000000);\n                    else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\n                    else return NaN;\n                } else {\n                    if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n                    else return x ^ (y & 0x80000000000000000000000000000000);\n                }\n            } else if (yExponent == 0x7FFF) {\n                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n                else return y ^ (x & 0x80000000000000000000000000000000);\n            } else {\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (xExponent == 0) xExponent = 1;\n                else xSignifier |= 0x10000000000000000000000000000;\n\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (yExponent == 0) yExponent = 1;\n                else ySignifier |= 0x10000000000000000000000000000;\n\n                xSignifier *= ySignifier;\n                if (xSignifier == 0)\n                    return (x ^ y) & 0x80000000000000000000000000000000 > 0 ? NEGATIVE_ZERO : POSITIVE_ZERO;\n\n                xExponent += yExponent;\n\n                uint256 msb = xSignifier >= 0x200000000000000000000000000000000000000000000000000000000\n                    ? 225\n                    : xSignifier >= 0x100000000000000000000000000000000000000000000000000000000\n                    ? 224\n                    : mostSignificantBit(xSignifier);\n\n                if (xExponent + msb < 16496) {\n                    // Underflow\n                    xExponent = 0;\n                    xSignifier = 0;\n                } else if (xExponent + msb < 16608) {\n                    // Subnormal\n                    if (xExponent < 16496) xSignifier >>= 16496 - xExponent;\n                    else if (xExponent > 16496) xSignifier <<= xExponent - 16496;\n                    xExponent = 0;\n                } else if (xExponent + msb > 49373) {\n                    xExponent = 0x7FFF;\n                    xSignifier = 0;\n                } else {\n                    if (msb > 112) xSignifier >>= msb - 112;\n                    else if (msb < 112) xSignifier <<= 112 - msb;\n\n                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n                    xExponent = xExponent + msb - 16607;\n                }\n\n                return\n                    bytes16(\n                        uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier)\n                    );\n            }\n        }\n    }\n\n    /**\n     * Calculate x / y.  Special values behave in the following way:\n     *\n     * NaN / x = NaN for any x.\n     * x / NaN = NaN for any x.\n     * Infinity / x = Infinity for any finite non-negative x.\n     * Infinity / x = -Infinity for any finite negative x including -0.\n     * -Infinity / x = -Infinity for any finite non-negative x.\n     * -Infinity / x = Infinity for any finite negative x including -0.\n     * x / Infinity = 0 for any finite non-negative x.\n     * x / -Infinity = -0 for any finite non-negative x.\n     * x / Infinity = -0 for any finite non-negative x including -0.\n     * x / -Infinity = 0 for any finite non-negative x including -0.\n     *\n     * Infinity / Infinity = NaN.\n     * Infinity / -Infinity = -NaN.\n     * -Infinity / Infinity = -NaN.\n     * -Infinity / -Infinity = NaN.\n     *\n     * Division by zero behaves in the following way:\n     *\n     * x / 0 = Infinity for any finite positive x.\n     * x / -0 = -Infinity for any finite positive x.\n     * x / 0 = -Infinity for any finite negative x.\n     * x / -0 = Infinity for any finite negative x.\n     * 0 / 0 = NaN.\n     * 0 / -0 = NaN.\n     * -0 / 0 = NaN.\n     * -0 / -0 = NaN.\n     *\n     * @param x quadruple precision number\n     * @param y quadruple precision number\n     * @return quadruple precision number\n     */\n    function div(bytes16 x, bytes16 y) internal pure returns (bytes16) {\n        unchecked {\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\n            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\n\n            if (xExponent == 0x7FFF) {\n                if (yExponent == 0x7FFF) return NaN;\n                else return x ^ (y & 0x80000000000000000000000000000000);\n            } else if (yExponent == 0x7FFF) {\n                if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\n                else return POSITIVE_ZERO | ((x ^ y) & 0x80000000000000000000000000000000);\n            } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\n                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n                else return POSITIVE_INFINITY | ((x ^ y) & 0x80000000000000000000000000000000);\n            } else {\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (yExponent == 0) yExponent = 1;\n                else ySignifier |= 0x10000000000000000000000000000;\n\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (xExponent == 0) {\n                    if (xSignifier != 0) {\n                        uint256 shift = 226 - mostSignificantBit(xSignifier);\n\n                        xSignifier <<= shift;\n\n                        xExponent = 1;\n                        yExponent += shift - 114;\n                    }\n                } else {\n                    xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\n                }\n\n                xSignifier = xSignifier / ySignifier;\n                if (xSignifier == 0)\n                    return (x ^ y) & 0x80000000000000000000000000000000 > 0 ? NEGATIVE_ZERO : POSITIVE_ZERO;\n\n                assert(xSignifier >= 0x1000000000000000000000000000);\n\n                uint256 msb = xSignifier >= 0x80000000000000000000000000000\n                    ? mostSignificantBit(xSignifier)\n                    : xSignifier >= 0x40000000000000000000000000000\n                    ? 114\n                    : xSignifier >= 0x20000000000000000000000000000\n                    ? 113\n                    : 112;\n\n                if (xExponent + msb > yExponent + 16497) {\n                    // Overflow\n                    xExponent = 0x7FFF;\n                    xSignifier = 0;\n                } else if (xExponent + msb + 16380 < yExponent) {\n                    // Underflow\n                    xExponent = 0;\n                    xSignifier = 0;\n                } else if (xExponent + msb + 16268 < yExponent) {\n                    // Subnormal\n                    if (xExponent + 16380 > yExponent) xSignifier <<= xExponent + 16380 - yExponent;\n                    else if (xExponent + 16380 < yExponent) xSignifier >>= yExponent - xExponent - 16380;\n\n                    xExponent = 0;\n                } else {\n                    // Normal\n                    if (msb > 112) xSignifier >>= msb - 112;\n\n                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n                    xExponent = xExponent + msb + 16269 - yExponent;\n                }\n\n                return\n                    bytes16(\n                        uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier)\n                    );\n            }\n        }\n    }\n\n    /**\n     * Calculate -x.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function neg(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            return x ^ 0x80000000000000000000000000000000;\n        }\n    }\n\n    /**\n     * Calculate |x|.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function abs(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        }\n    }\n\n    /**\n     * Calculate square root of x.  Return NaN on negative x excluding -0.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function sqrt(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\n            else {\n                uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\n                if (xExponent == 0x7FFF) return x;\n                else {\n                    uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                    if (xExponent == 0) xExponent = 1;\n                    else xSignifier |= 0x10000000000000000000000000000;\n\n                    if (xSignifier == 0) return POSITIVE_ZERO;\n\n                    bool oddExponent = xExponent & 0x1 == 0;\n                    xExponent = (xExponent + 16383) >> 1;\n\n                    if (oddExponent) {\n                        if (xSignifier >= 0x10000000000000000000000000000) xSignifier <<= 113;\n                        else {\n                            uint256 msb = mostSignificantBit(xSignifier);\n                            uint256 shift = (226 - msb) & 0xFE;\n                            xSignifier <<= shift;\n                            xExponent -= (shift - 112) >> 1;\n                        }\n                    } else {\n                        if (xSignifier >= 0x10000000000000000000000000000) xSignifier <<= 112;\n                        else {\n                            uint256 msb = mostSignificantBit(xSignifier);\n                            uint256 shift = (225 - msb) & 0xFE;\n                            xSignifier <<= shift;\n                            xExponent -= (shift - 112) >> 1;\n                        }\n                    }\n\n                    uint256 r = 0x10000000000000000000000000000;\n                    r = (r + xSignifier / r) >> 1;\n                    r = (r + xSignifier / r) >> 1;\n                    r = (r + xSignifier / r) >> 1;\n                    r = (r + xSignifier / r) >> 1;\n                    r = (r + xSignifier / r) >> 1;\n                    r = (r + xSignifier / r) >> 1;\n                    r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\n                    uint256 r1 = xSignifier / r;\n                    if (r1 < r) r = r1;\n\n                    return bytes16(uint128((xExponent << 112) | (r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)));\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function log_2(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\n            else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO;\n            else {\n                uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\n                if (xExponent == 0x7FFF) return x;\n                else {\n                    uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                    if (xExponent == 0) xExponent = 1;\n                    else xSignifier |= 0x10000000000000000000000000000;\n\n                    if (xSignifier == 0) return NEGATIVE_INFINITY;\n\n                    bool resultNegative;\n                    uint256 resultExponent = 16495;\n                    uint256 resultSignifier;\n\n                    if (xExponent >= 0x3FFF) {\n                        resultNegative = false;\n                        resultSignifier = xExponent - 0x3FFF;\n                        xSignifier <<= 15;\n                    } else {\n                        resultNegative = true;\n                        if (xSignifier >= 0x10000000000000000000000000000) {\n                            resultSignifier = 0x3FFE - xExponent;\n                            xSignifier <<= 15;\n                        } else {\n                            uint256 msb = mostSignificantBit(xSignifier);\n                            resultSignifier = 16493 - msb;\n                            xSignifier <<= 127 - msb;\n                        }\n                    }\n\n                    if (xSignifier == 0x80000000000000000000000000000000) {\n                        if (resultNegative) resultSignifier += 1;\n                        uint256 shift = 112 - mostSignificantBit(resultSignifier);\n                        resultSignifier <<= shift;\n                        resultExponent -= shift;\n                    } else {\n                        uint256 bb = resultNegative ? 1 : 0;\n                        while (resultSignifier < 0x10000000000000000000000000000) {\n                            resultSignifier <<= 1;\n                            resultExponent -= 1;\n\n                            xSignifier *= xSignifier;\n                            uint256 b = xSignifier >> 255;\n                            resultSignifier += b ^ bb;\n                            xSignifier >>= 127 + b;\n                        }\n                    }\n\n                    return\n                        bytes16(\n                            uint128(\n                                (resultNegative ? 0x80000000000000000000000000000000 : 0) |\n                                    (resultExponent << 112) |\n                                    (resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n                            )\n                        );\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function ln(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            return mul(log_2(x), 0x3FFE62E42FEFA39EF35793C7673007E5);\n        }\n    }\n\n    /**\n     * Calculate 2^x.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function pow_2(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            bool xNegative = uint128(x) > 0x80000000000000000000000000000000;\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\n            uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\n            else if (xExponent > 16397) return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\n            else if (xExponent < 16255) return 0x3FFF0000000000000000000000000000;\n            else {\n                if (xExponent == 0) xExponent = 1;\n                else xSignifier |= 0x10000000000000000000000000000;\n\n                if (xExponent > 16367) xSignifier <<= xExponent - 16367;\n                else if (xExponent < 16367) xSignifier >>= 16367 - xExponent;\n\n                if (xNegative && xSignifier > 0x406E00000000000000000000000000000000) return POSITIVE_ZERO;\n\n                if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) return POSITIVE_INFINITY;\n\n                uint256 resultExponent = xSignifier >> 128;\n                xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                if (xNegative && xSignifier != 0) {\n                    xSignifier = ~xSignifier;\n                    resultExponent += 1;\n                }\n\n                uint256 resultSignifier = 0x80000000000000000000000000000000;\n                if (xSignifier & 0x80000000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\n                if (xSignifier & 0x40000000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;\n                if (xSignifier & 0x20000000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;\n                if (xSignifier & 0x10000000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10B5586CF9890F6298B92B71842A98363) >> 128;\n                if (xSignifier & 0x8000000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;\n                if (xSignifier & 0x4000000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;\n                if (xSignifier & 0x2000000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;\n                if (xSignifier & 0x1000000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;\n                if (xSignifier & 0x800000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;\n                if (xSignifier & 0x400000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;\n                if (xSignifier & 0x200000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;\n                if (xSignifier & 0x100000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;\n                if (xSignifier & 0x80000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;\n                if (xSignifier & 0x40000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;\n                if (xSignifier & 0x20000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000162E525EE054754457D5995292026) >> 128;\n                if (xSignifier & 0x10000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;\n                if (xSignifier & 0x8000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;\n                if (xSignifier & 0x4000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;\n                if (xSignifier & 0x2000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\n                if (xSignifier & 0x1000000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\n                if (xSignifier & 0x800000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;\n                if (xSignifier & 0x400000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;\n                if (xSignifier & 0x200000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000162E430E5A18F6119E3C02282A5) >> 128;\n                if (xSignifier & 0x100000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;\n                if (xSignifier & 0x80000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;\n                if (xSignifier & 0x40000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;\n                if (xSignifier & 0x20000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;\n                if (xSignifier & 0x10000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;\n                if (xSignifier & 0x8000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;\n                if (xSignifier & 0x4000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;\n                if (xSignifier & 0x2000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;\n                if (xSignifier & 0x1000000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\n                if (xSignifier & 0x800000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;\n                if (xSignifier & 0x400000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;\n                if (xSignifier & 0x200000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\n                if (xSignifier & 0x100000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;\n                if (xSignifier & 0x80000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;\n                if (xSignifier & 0x40000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;\n                if (xSignifier & 0x20000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\n                if (xSignifier & 0x10000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000B17217F7D20CF927C8E94C) >> 128;\n                if (xSignifier & 0x8000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;\n                if (xSignifier & 0x4000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000002C5C85FDF477B662B26945) >> 128;\n                if (xSignifier & 0x2000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000162E42FEFA3AE53369388C) >> 128;\n                if (xSignifier & 0x1000000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000B17217F7D1D351A389D40) >> 128;\n                if (xSignifier & 0x800000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;\n                if (xSignifier & 0x400000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;\n                if (xSignifier & 0x200000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000162E42FEFA39FE95583C2) >> 128;\n                if (xSignifier & 0x100000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;\n                if (xSignifier & 0x80000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;\n                if (xSignifier & 0x40000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000002C5C85FDF473E242EA38) >> 128;\n                if (xSignifier & 0x20000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000162E42FEFA39F02B772C) >> 128;\n                if (xSignifier & 0x10000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\n                if (xSignifier & 0x8000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\n                if (xSignifier & 0x4000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000002C5C85FDF473DEA871F) >> 128;\n                if (xSignifier & 0x2000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000162E42FEFA39EF44D91) >> 128;\n                if (xSignifier & 0x1000000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000B17217F7D1CF79E949) >> 128;\n                if (xSignifier & 0x800000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000058B90BFBE8E7BCE544) >> 128;\n                if (xSignifier & 0x400000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\n                if (xSignifier & 0x200000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000162E42FEFA39EF366F) >> 128;\n                if (xSignifier & 0x100000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\n                if (xSignifier & 0x80000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;\n                if (xSignifier & 0x40000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000002C5C85FDF473DE6B2) >> 128;\n                if (xSignifier & 0x20000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000162E42FEFA39EF358) >> 128;\n                if (xSignifier & 0x10000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000B17217F7D1CF79AB) >> 128;\n                if (xSignifier & 0x8000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5) >> 128;\n                if (xSignifier & 0x4000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000002C5C85FDF473DE6A) >> 128;\n                if (xSignifier & 0x2000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000162E42FEFA39EF34) >> 128;\n                if (xSignifier & 0x1000000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000B17217F7D1CF799) >> 128;\n                if (xSignifier & 0x800000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000058B90BFBE8E7BCC) >> 128;\n                if (xSignifier & 0x400000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000002C5C85FDF473DE5) >> 128;\n                if (xSignifier & 0x200000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000162E42FEFA39EF2) >> 128;\n                if (xSignifier & 0x100000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000B17217F7D1CF78) >> 128;\n                if (xSignifier & 0x80000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000058B90BFBE8E7BB) >> 128;\n                if (xSignifier & 0x40000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000002C5C85FDF473DD) >> 128;\n                if (xSignifier & 0x20000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000162E42FEFA39EE) >> 128;\n                if (xSignifier & 0x10000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000B17217F7D1CF6) >> 128;\n                if (xSignifier & 0x8000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000058B90BFBE8E7A) >> 128;\n                if (xSignifier & 0x4000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000002C5C85FDF473C) >> 128;\n                if (xSignifier & 0x2000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000162E42FEFA39D) >> 128;\n                if (xSignifier & 0x1000000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000B17217F7D1CE) >> 128;\n                if (xSignifier & 0x800000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000058B90BFBE8E6) >> 128;\n                if (xSignifier & 0x400000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000002C5C85FDF472) >> 128;\n                if (xSignifier & 0x200000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000162E42FEFA38) >> 128;\n                if (xSignifier & 0x100000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000B17217F7D1B) >> 128;\n                if (xSignifier & 0x80000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000058B90BFBE8D) >> 128;\n                if (xSignifier & 0x40000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000002C5C85FDF46) >> 128;\n                if (xSignifier & 0x20000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000162E42FEFA2) >> 128;\n                if (xSignifier & 0x10000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000B17217F7D0) >> 128;\n                if (xSignifier & 0x8000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000058B90BFBE7) >> 128;\n                if (xSignifier & 0x4000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000002C5C85FDF3) >> 128;\n                if (xSignifier & 0x2000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000162E42FEF9) >> 128;\n                if (xSignifier & 0x1000000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000B17217F7C) >> 128;\n                if (xSignifier & 0x800000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000058B90BFBD) >> 128;\n                if (xSignifier & 0x400000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000002C5C85FDE) >> 128;\n                if (xSignifier & 0x200000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000162E42FEE) >> 128;\n                if (xSignifier & 0x100000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000B17217F6) >> 128;\n                if (xSignifier & 0x80000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000058B90BFA) >> 128;\n                if (xSignifier & 0x40000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000002C5C85FC) >> 128;\n                if (xSignifier & 0x20000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000162E42FD) >> 128;\n                if (xSignifier & 0x10000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000B17217E) >> 128;\n                if (xSignifier & 0x8000000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000058B90BE) >> 128;\n                if (xSignifier & 0x4000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000002C5C85E) >> 128;\n                if (xSignifier & 0x2000000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000162E42E) >> 128;\n                if (xSignifier & 0x1000000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000B17216) >> 128;\n                if (xSignifier & 0x800000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000058B90A) >> 128;\n                if (xSignifier & 0x400000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000002C5C84) >> 128;\n                if (xSignifier & 0x200000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000162E41) >> 128;\n                if (xSignifier & 0x100000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000B1720) >> 128;\n                if (xSignifier & 0x80000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000058B8F) >> 128;\n                if (xSignifier & 0x40000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000002C5C7) >> 128;\n                if (xSignifier & 0x20000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000162E3) >> 128;\n                if (xSignifier & 0x10000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000B171) >> 128;\n                if (xSignifier & 0x8000 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000058B8) >> 128;\n                if (xSignifier & 0x4000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000002C5B) >> 128;\n                if (xSignifier & 0x2000 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000162D) >> 128;\n                if (xSignifier & 0x1000 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000B16) >> 128;\n                if (xSignifier & 0x800 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000058A) >> 128;\n                if (xSignifier & 0x400 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000002C4) >> 128;\n                if (xSignifier & 0x200 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000161) >> 128;\n                if (xSignifier & 0x100 > 0)\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000000B0) >> 128;\n                if (xSignifier & 0x80 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000057) >> 128;\n                if (xSignifier & 0x40 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000002B) >> 128;\n                if (xSignifier & 0x20 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000015) >> 128;\n                if (xSignifier & 0x10 > 0)\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000000A) >> 128;\n                if (xSignifier & 0x8 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000004) >> 128;\n                if (xSignifier & 0x4 > 0)\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000001) >> 128;\n\n                if (!xNegative) {\n                    resultSignifier = (resultSignifier >> 15) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                    resultExponent += 0x3FFF;\n                } else if (resultExponent <= 0x3FFE) {\n                    resultSignifier = (resultSignifier >> 15) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                    resultExponent = 0x3FFF - resultExponent;\n                } else {\n                    resultSignifier = resultSignifier >> (resultExponent - 16367);\n                    resultExponent = 0;\n                }\n\n                return bytes16(uint128((resultExponent << 112) | resultSignifier));\n            }\n        }\n    }\n\n    /**\n     * Calculate e^x.\n     *\n     * @param x quadruple precision number\n     * @return quadruple precision number\n     */\n    function exp(bytes16 x) internal pure returns (bytes16) {\n        unchecked {\n            return pow_2(mul(x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\n        }\n    }\n\n    /**\n     * Get index of the most significant non-zero bit in binary representation of\n     * x.  Reverts if x is zero.\n     *\n     * @return index of the most significant non-zero bit in binary representation\n     *         of x\n     */\n    function mostSignificantBit(uint256 x) private pure returns (uint256) {\n        unchecked {\n            require(x > 0, REQUIRE_ERROR);\n\n            uint256 result = 0;\n\n            if (x >= 0x100000000000000000000000000000000) {\n                x >>= 128;\n                result += 128;\n            }\n            if (x >= 0x10000000000000000) {\n                x >>= 64;\n                result += 64;\n            }\n            if (x >= 0x100000000) {\n                x >>= 32;\n                result += 32;\n            }\n            if (x >= 0x10000) {\n                x >>= 16;\n                result += 16;\n            }\n            if (x >= 0x100) {\n                x >>= 8;\n                result += 8;\n            }\n            if (x >= 0x10) {\n                x >>= 4;\n                result += 4;\n            }\n            if (x >= 0x4) {\n                x >>= 2;\n                result += 2;\n            }\n            if (x >= 0x2) result += 1; // No need to shift x anymore\n\n            return result;\n        }\n    }\n}\n"
    },
    "src/Interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "src/Interfaces/IDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5 <=0.8.10;\n\ninterface IDistributor {\n    function distribute() external;\n\n    function bounty() external view returns (uint256);\n\n    function retrieveBounty() external returns (uint256);\n\n    function nextRewardAt(uint256 _rate, address _recipient) external view returns (uint256);\n\n    function nextRewardFor(address _recipient) external view returns (uint256);\n\n    function nextRewardRate(uint256 _index) external view returns (uint256);\n\n    function setBounty(uint256 _bounty) external;\n\n    function addRecipient(\n        address _recipient,\n        uint256 _startRate,\n        int256 _drs,\n        int256 _dys,\n        bool _locked\n    ) external;\n\n    function removeRecipient(uint256 _index) external;\n\n    function setDiscountRateStaking(uint256 _index, int256 _drs) external;\n\n    function setDiscountRateYield(uint256 _index, int256 _dys) external;\n\n    function setStaking(address _addr) external;\n}\n"
    },
    "src/Interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IStaking {\n    function stake(\n        address _to,\n        uint256 _amount,\n        bool _claim\n    ) external returns (uint256, uint256 _index);\n\n    function claim(address _recipient, bool _rebasing) external returns (uint256);\n\n    function forfeit(uint256 _index) external;\n\n    function toggleLock() external;\n\n    function unstake(\n        address _to,\n        uint256 _amount,\n        bool _trigger,\n        bool _rebasing\n    ) external returns (uint256);\n\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_);\n\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_);\n\n    function rebase() external;\n\n    function index() external view returns (uint256);\n\n    function contractBalance() external view returns (uint256);\n\n    function totalStaked() external view returns (uint256);\n\n    function supplyInWarmup() external view returns (uint256);\n\n    function indexesFor(address _user) external view returns (uint256[] memory);\n\n    function claimAll(address _recipient) external returns (uint256);\n\n    function pushClaim(address _to, uint256 _index) external;\n\n    function pullClaim(address _from, uint256 _index) external returns (uint256 newIndex_);\n\n    function pushClaimForBond(address _to, uint256 _index) external returns (uint256 newIndex_);\n\n    function basis() external view returns (address);\n}\n"
    },
    "src/Interfaces/IStakedTHEOToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IStakedTHEOToken is IERC20 {\n    function rebase(uint256 theoProfit_, uint256 epoch_) external returns (uint256);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view override returns (uint256);\n\n    function gonsForBalance(uint256 amount) external view returns (uint256);\n\n    function balanceForGons(uint256 gons) external view returns (uint256);\n\n    function index() external view returns (uint256);\n}\n"
    },
    "src/Interfaces/ITHEO.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface ITHEO is IERC20 {\n    function mint(address account_, uint256 amount_) external;\n\n    function burn(uint256 amount) external;\n\n    function burnFrom(address account_, uint256 amount_) external;\n}\n"
    },
    "src/Types/FrontEndRewarder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"../Types/TheopetraAccessControlled.sol\";\nimport \"../Interfaces/IERC20.sol\";\n\nabstract contract FrontEndRewarder is TheopetraAccessControlled {\n    /* ========= STATE VARIABLES ========== */\n\n    uint256 public daoReward; // % reward for dao (3 decimals: 100 = 1%)\n    uint256 public refReward; // % reward for referrer (3 decimals: 100 = 1%)\n    mapping(address => uint256) public rewards; // front end operator rewards\n    mapping(address => bool) public whitelisted; // whitelisted status for operators\n\n    IERC20 internal immutable theo; // reward token\n\n    event SetRewards(uint256 toRef, uint256 toDao);\n    constructor(ITheopetraAuthority _authority, IERC20 _theo) TheopetraAccessControlled(_authority) {\n        theo = _theo;\n    }\n\n    /* ========= EXTERNAL FUNCTIONS ========== */\n\n    // pay reward to front end operator\n    function getReward() external {\n        uint256 reward = rewards[msg.sender];\n\n        rewards[msg.sender] = 0;\n        theo.transfer(msg.sender, reward);\n    }\n\n    /* ========= INTERNAL ========== */\n\n    /**\n     * @notice add new market payout to user data\n     */\n    function _giveRewards(uint256 _payout, address _referral) internal returns (uint256) {\n        // first we calculate rewards paid to the DAO and to the front end operator (referrer)\n        uint256 toDAO = (_payout * daoReward) / 1e4;\n        uint256 toRef = (_payout * refReward) / 1e4;\n\n        // and store them in our rewards mapping\n        if (whitelisted[_referral]) {\n            rewards[_referral] += toRef;\n            rewards[authority.guardian()] += toDAO;\n        } else {\n            // the DAO receives both rewards if referrer is not whitelisted\n            rewards[authority.guardian()] += toDAO + toRef;\n        }\n        return toDAO + toRef;\n    }\n\n    /**\n     * @notice set rewards for front end operators and DAO\n     */\n    function setRewards(uint256 _toFrontEnd, uint256 _toDAO) external onlyGovernor {\n        refReward = _toFrontEnd;\n        daoReward = _toDAO;\n\n        emit SetRewards(_toFrontEnd, _toDAO);\n    }\n\n    /**\n     * @notice add or remove addresses from the reward whitelist\n     */\n    function whitelist(address _operator) external onlyPolicy {\n        whitelisted[_operator] = !whitelisted[_operator];\n    }\n}\n"
    },
    "src/Types/NoteKeeper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"./FrontEndRewarder.sol\";\n\nimport \"../Interfaces/IStakedTHEOToken.sol\";\nimport \"../Interfaces/IStaking.sol\";\nimport \"../Interfaces/ITreasury.sol\";\nimport \"../Interfaces/INoteKeeper.sol\";\n\nabstract contract NoteKeeper is INoteKeeper, FrontEndRewarder {\n    mapping(address => Note[]) public notes; // user deposit data\n    mapping(address => mapping(uint256 => address)) private noteTransfers; // change note ownership\n    mapping(address => mapping(uint256 => uint256)) private noteForClaim; // index of staking claim for a user's note\n\n    event TreasuryUpdated(address addr);\n    event PushNote(address from, address to, uint256 noteId);\n    event PullNote(address from, address to, uint256 noteId);\n\n    IStakedTHEOToken internal immutable sTHEO;\n    IStaking internal immutable staking;\n    ITreasury internal treasury;\n\n    constructor(\n        ITheopetraAuthority _authority,\n        IERC20 _theo,\n        IStakedTHEOToken _stheo,\n        IStaking _staking,\n        ITreasury _treasury\n    ) FrontEndRewarder(_authority, _theo) {\n        sTHEO = _stheo;\n        staking = _staking;\n        treasury = _treasury;\n    }\n\n    // if treasury address changes on authority, update it\n    function updateTreasury() external {\n        require(\n            msg.sender == authority.governor() ||\n                msg.sender == authority.guardian() ||\n                msg.sender == authority.policy(),\n            \"Only authorized\"\n        );\n        address treasuryAddress = authority.vault();\n        treasury = ITreasury(treasuryAddress);\n        emit TreasuryUpdated(treasuryAddress);\n    }\n\n    /* ========== ADD ========== */\n\n    /**\n     * @notice             adds a new Note for a user, stores the front end & DAO rewards, and mints & stakes payout & rewards\n     * @param _user        the user that owns the Note\n     * @param _payout      the amount of THEO due to the user\n     * @param _expiry      the timestamp when the Note is redeemable\n     * @param _marketID    the ID of the market deposited into\n     * @param _discount    the discount on the bond (that is, the bond rate, variable). This is a proportion (that is, a percentage in its decimal form), with 9 decimals\n     * @return index_      the index of the Note in the user's array\n     */\n    function addNote(\n        address _user,\n        uint256 _payout,\n        uint48 _expiry,\n        uint48 _marketID,\n        address _referral,\n        uint48 _discount,\n        bool _autoStake\n    ) internal returns (uint256 index_) {\n        // the index of the note is the next in the user's array\n        index_ = notes[_user].length;\n\n        // the new note is pushed to the user's array\n        notes[_user].push(\n            Note({\n                payout: _payout,\n                created: uint48(block.timestamp),\n                matured: _expiry,\n                redeemed: 0,\n                marketID: _marketID,\n                discount: _discount,\n                autoStake: _autoStake\n            })\n        );\n\n        // front end operators can earn rewards by referring users\n        uint256 rewards = _giveRewards(_payout, _referral);\n\n        // mint and stake payout\n        treasury.mint(address(this), _payout + rewards);\n\n        if (_autoStake) {\n            // note that only the payout gets staked (front end rewards are in THEO)\n            // Get index for the claim to approve for pushing\n            (, uint256 claimIndex) = staking.stake(address(this), _payout, true);\n            // approve the user to transfer the staking claim\n            staking.pushClaim(_user, claimIndex);\n\n            // Map the index of the user's note to the claimIndex\n            noteForClaim[_user][index_] = claimIndex;\n        }\n    }\n\n    /* ========== REDEEM ========== */\n\n    /**\n     * @notice             redeem notes for user\n     * @dev                adapted from Olympus V2. Olympus V2 either sends payout as gOHM\n     *                     or calls an `unwrap` function on the staking contract\n     *                     to convert the payout from gOHM into sOHM and then send as sOHM.\n     *                     This current contract sends payout as sTHEO.\n     * @param _user        the user to redeem for\n     * @param _indexes     the note indexes to redeem\n     * @return payout_     sum of payout sent, in sTHEO\n     */\n    function redeem(address _user, uint256[] memory _indexes) public override returns (uint256 payout_) {\n        uint48 time = uint48(block.timestamp);\n        uint256 sTheoPayout = 0;\n        uint256 theoPayout = 0;\n\n        for (uint256 i = 0; i < _indexes.length; i++) {\n            (uint256 pay, , , , bool matured, ) = pendingFor(_user, _indexes[i]);\n\n            if (matured) {\n                notes[_user][_indexes[i]].redeemed = time; // mark as redeemed\n                payout_ += pay;\n                if (notes[_user][_indexes[i]].autoStake) {\n                    uint256 _claimIndex = noteForClaim[_user][_indexes[i]];\n                    staking.pushClaimForBond(_user, _claimIndex);\n                    sTheoPayout += pay;\n                } else {\n                    theoPayout += pay;\n                }\n            }\n        }\n        if (theoPayout > 0) theo.transfer(_user, theoPayout);\n        if (sTheoPayout > 0) sTHEO.transfer(_user, sTheoPayout);\n    }\n\n    /**\n     * @notice             redeem all redeemable markets for user\n     * @dev                if possible, query indexesFor() off-chain and input in redeem() to save gas\n     * @param _user        user to redeem all notes for\n     * @return             sum of payout sent, in sTHEO\n     */\n    function redeemAll(address _user) external override returns (uint256) {\n        return redeem(_user, indexesFor(_user));\n    }\n\n    /* ========== TRANSFER ========== */\n\n    /**\n     * @notice             approve an address to transfer a note\n     * @param _to          address to approve note transfer for\n     * @param _index       index of note to approve transfer for\n     */\n    function pushNote(address _to, uint256 _index) external override {\n        require(notes[msg.sender][_index].created != 0, \"Depository: note not found\");\n        noteTransfers[msg.sender][_index] = _to;\n\n        emit PushNote(msg.sender, _to, _index);\n    }\n\n    /**\n     * @notice             transfer a note that has been approved by an address\n     * @dev                if the note being pulled is autostaked then update noteForClaim as follows:\n     *                     get the relevant `claimIndex` associated with the note that is being pulled.\n     *                     Then add the claimIndex to the recipient's noteForClaim.\n     *                     After updating noteForClaim, the staking claim is pushed to the recipient, in order to\n     *                     update `claimTransfers` in the Staking contract and thereby change claim ownership (from the note's pusher to the note's recipient)\n     * @param _from        the address that approved the note transfer\n     * @param _index       the index of the note to transfer (in the sender's array)\n     */\n    function pullNote(address _from, uint256 _index) external override returns (uint256 newIndex_) {\n        require(noteTransfers[_from][_index] == msg.sender, \"Depository: transfer not found\");\n        require(notes[_from][_index].redeemed == 0, \"Depository: note redeemed\");\n\n        newIndex_ = notes[msg.sender].length;\n\n        if (notes[_from][_index].autoStake) {\n            uint256 claimIndex = noteForClaim[_from][_index];\n            noteForClaim[msg.sender][newIndex_] = claimIndex;\n            staking.pushClaim(msg.sender, claimIndex);\n        }\n        notes[msg.sender].push(notes[_from][_index]);\n\n        delete notes[_from][_index];\n        emit PullNote(_from, msg.sender, _index);\n    }\n\n    /* ========== VIEW ========== */\n\n    // Note info\n\n    /**\n     * @notice             all pending notes for user\n     * @param _user        the user to query notes for\n     * @return             the pending notes for the user\n     */\n    function indexesFor(address _user) public view override returns (uint256[] memory) {\n        Note[] memory info = notes[_user];\n\n        uint256 length;\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].redeemed == 0 && info[i].payout != 0) length++;\n        }\n\n        uint256[] memory indexes = new uint256[](length);\n        uint256 position;\n\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].redeemed == 0 && info[i].payout != 0) {\n                indexes[position] = i;\n                position++;\n            }\n        }\n\n        return indexes;\n    }\n\n    /**\n     * @notice                  calculate amount available for claim for a single note\n     * @param _user             the user that the note belongs to\n     * @param _index            the index of the note in the user's array\n     * @return payout_          the payout due, in sTHEO\n     * @return created_         the time the note was created\n     * @return expiry_          the time the note is redeemable\n     * @return timeRemaining_   the time remaining until the note is matured\n     * @return matured_         if the payout can be redeemed\n     */\n    function pendingFor(address _user, uint256 _index)\n        public\n        view\n        override\n        returns (\n            uint256 payout_,\n            uint48 created_,\n            uint48 expiry_,\n            uint48 timeRemaining_,\n            bool matured_,\n            uint48 discount_\n        )\n    {\n        Note memory note = notes[_user][_index];\n\n        payout_ = note.payout;\n        created_ = note.created;\n        expiry_ = note.matured;\n        timeRemaining_ = note.matured > block.timestamp ? uint48(note.matured - block.timestamp) : 0;\n        matured_ = note.redeemed == 0 && note.matured <= block.timestamp && note.payout != 0;\n        discount_ = note.discount;\n    }\n\n    function getNotesCount(address _user) external view returns (uint256) {\n        return notes[_user].length;\n    }\n}\n"
    },
    "src/Interfaces/INoteKeeper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\ninterface INoteKeeper {\n    /**\n     * @notice  Info for market note\n     * @dev     Note::payout is sTHEO remaining to be paid\n     *          Note::created is the time the Note was created\n     *          Note::matured is the timestamp when the Note is redeemable\n     *          Note::redeemed is time market was redeemed\n     *          Note::marketID is market ID of deposit. uint48 to avoid adding a slot.\n     */\n    struct Note {\n        uint256 payout;\n        uint48 created;\n        uint48 matured;\n        uint48 redeemed;\n        uint48 marketID;\n        uint48 discount;\n        bool autoStake;\n    }\n\n    function redeem(address _user, uint256[] memory _indexes) external returns (uint256);\n\n    function redeemAll(address _user) external returns (uint256);\n\n    function pushNote(address to, uint256 index) external;\n\n    function pullNote(address from, uint256 index) external returns (uint256 newIndex_);\n\n    function indexesFor(address _user) external view returns (uint256[] memory);\n\n    function pendingFor(address _user, uint256 _index)\n        external\n        view\n        returns (\n            uint256 payout_,\n            uint48 created_,\n            uint48 expiry_,\n            uint48 timeRemaining_,\n            bool matured_,\n            uint48 discount_\n        );\n}\n"
    },
    "src/Theopetra/WhitelistBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"../Types/NoteKeeper.sol\";\nimport \"../Types/Signed.sol\";\nimport \"../Types/PriceConsumerV3.sol\";\n\nimport \"../Libraries/SafeERC20.sol\";\n\nimport \"../Interfaces/IERC20Metadata.sol\";\nimport \"../Interfaces/IWhitelistBondDepository.sol\";\n\n/**\n * @title Theopetra Whitelist Bond Depository\n */\n\ncontract WhitelistTheopetraBondDepository is IWhitelistBondDepository, NoteKeeper, Signed, PriceConsumerV3 {\n    /* ======== DEPENDENCIES ======== */\n\n    using SafeERC20 for IERC20;\n\n    /* ======== EVENTS ======== */\n\n    event CreateMarket(\n        uint256 indexed id,\n        address indexed baseToken,\n        address indexed quoteToken,\n        uint256 fixedBondPrice\n    );\n    event CloseMarket(uint256 indexed id);\n    event Bond(uint256 indexed id, uint256 amount, uint256 price);\n\n    /* ======== STATE VARIABLES ======== */\n\n    // Storage\n    Market[] public markets; // persistent market data\n    Terms[] public terms; // deposit construction data\n    Metadata[] public metadata; // extraneous market data\n    address private wethHelper;\n\n    // Queries\n    mapping(address => uint256[]) public marketsForQuote; // market IDs for quote token\n\n    /* ======== CONSTRUCTOR ======== */\n\n    constructor(\n        ITheopetraAuthority _authority,\n        IERC20 _theo,\n        IStakedTHEOToken _stheo,\n        IStaking _staking,\n        ITreasury _treasury\n    ) NoteKeeper(_authority, _theo, _stheo, _staking, _treasury) {\n        // save gas for users by bulk approving stake() transactions\n        _theo.approve(address(_staking), 1e45);\n    }\n\n    /* ======== DEPOSIT ======== */\n\n    /**\n     * @notice             deposit quote tokens in exchange for a bond from a specified market\n     * @param _id          the ID of the market\n     * @param _amount      the amount of quote token to spend\n     * @param _maxPrice    the maximum price at which to buy\n     * @param _user        the recipient of the payout\n     * @param _referral    the front end operator address\n     * @return depositInfo DepositInfo\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _user,\n        address _referral,\n        bytes calldata signature\n    ) external override returns (DepositInfo memory depositInfo) {\n        if (msg.sender != wethHelper) {\n            verifySignature(\"\", signature);\n        }\n        Market storage market = markets[_id];\n        Terms memory term = terms[_id];\n        uint48 currentTime = uint48(block.timestamp);\n\n        // Markets end at a defined timestamp\n        // |-------------------------------------| t\n        require(currentTime < term.conclusion, \"Depository: market concluded\");\n\n        // Get the price of THEO in quote token terms\n        // i.e. the number of quote tokens per THEO\n        // With 9 decimal places\n        uint256 price = calculatePrice(_id);\n\n        // Users input a maximum price, which protects them from price changes after\n        // entering the mempool. max price is a slippage mitigation measure\n        require(price <= _maxPrice, \"Depository: more than max price\");\n\n        /**\n         * payout for the deposit = amount / price\n         *\n         * where\n         * payout = THEO out, in THEO decimals (9)\n         * amount = quote tokens in\n         * price = quote tokens per THEO, in THEO decimals (9)\n         *\n         * 1e18 = THEO decimals (9) + price decimals (9)\n         */\n        depositInfo.payout_ = ((_amount * 1e18) / price) / (10**metadata[_id].quoteDecimals);\n\n        /*\n         * each market is initialized with a capacity\n         *\n         * this is either the number of THEO that the market can sell\n         * (if capacity in quote is false),\n         *\n         * or the number of quote tokens that the market can buy\n         * (if capacity in quote is true)\n         */\n\n        require(\n            market.capacity >= (market.capacityInQuote ? _amount : depositInfo.payout_),\n            \"Depository: capacity exceeded\"\n        );\n\n        market.capacity -= market.capacityInQuote ? _amount : depositInfo.payout_;\n\n        if (market.capacity == 0) {\n            emit CloseMarket(_id);\n        }\n\n        /**\n         * bonds mature with a cliff at a set timestamp\n         * prior to the expiry timestamp, no payout tokens are accessible to the user\n         * after the expiry timestamp, the entire payout can be redeemed\n         *\n         * there are two types of bonds: fixed-term and fixed-expiration\n         *\n         * fixed-term bonds mature in a set amount of time from deposit\n         * i.e. term = 1 week. when alice deposits on day 1, her bond\n         * expires on day 8. when bob deposits on day 2, his bond expires day 9.\n         *\n         * fixed-expiration bonds mature at a set timestamp\n         * i.e. expiration = day 10. when alice deposits on day 1, her term\n         * is 9 days. when bob deposits on day 2, his term is 8 days.\n         */\n        depositInfo.expiry_ = term.fixedTerm ? term.vesting + currentTime : term.vesting;\n\n        // markets keep track of how many quote tokens have been\n        // purchased, and how much THEO has been sold\n        market.purchased += _amount;\n        market.sold += uint64(depositInfo.payout_);\n\n        emit Bond(_id, _amount, price);\n\n        /**\n         * user data is stored as Notes. these are isolated array entries\n         * storing the amount due, the time created, the time when payout\n         * is redeemable, the time when payout was redeemed, and the ID\n         * of the market deposited into\n         */\n        depositInfo.index_ = addNote(\n            _user,\n            depositInfo.payout_,\n            uint48(depositInfo.expiry_),\n            uint48(_id),\n            _referral,\n            0,\n            false\n        );\n\n        // transfer payment to treasury\n        market.quoteToken.safeTransferFrom(msg.sender, address(treasury), _amount);\n    }\n\n    /* ======== CREATE ======== */\n\n    /**\n     * @notice             creates a new market type\n     * @dev                current price should be in 9 decimals.\n     * @param _quoteToken  token used to deposit\n     * @param _market      [capacity (in THEO or quote), fixed bond price (9 decimals) USD per THEO]\n     * @param _booleans    [capacity in quote, fixed term]\n     * @param _terms       [vesting length (if fixed term) or vested timestamp, conclusion timestamp]\n     * @param _priceFeed   address of the price consumer, to return the USD value for the quote token when deposits are made\n     * @return id_         ID of new bond market\n     */\n    function create(\n        IERC20 _quoteToken,\n        address _priceFeed,\n        uint256[2] memory _market,\n        bool[2] memory _booleans,\n        uint256[2] memory _terms\n    ) external override onlyPolicy returns (uint256 id_) {\n        // the decimal count of the quote token\n        uint256 decimals = IERC20Metadata(address(_quoteToken)).decimals();\n\n        // depositing into, or getting info for, the created market uses this ID\n        id_ = markets.length;\n\n        markets.push(\n            Market({\n                quoteToken: _quoteToken,\n                priceFeed: _priceFeed,\n                capacityInQuote: _booleans[0],\n                capacity: _market[0],\n                purchased: 0,\n                sold: 0,\n                usdPricePerTHEO: _market[1]\n            })\n        );\n\n        terms.push(Terms({ fixedTerm: _booleans[1], vesting: uint48(_terms[0]), conclusion: uint48(_terms[1]) }));\n\n        metadata.push(Metadata({ quoteDecimals: uint8(decimals) }));\n\n        marketsForQuote[address(_quoteToken)].push(id_);\n\n        emit CreateMarket(id_, address(theo), address(_quoteToken), _market[1]);\n    }\n\n    /**\n     * @notice             disable existing market\n     * @param _id          ID of market to close\n     */\n    function close(uint256 _id) external override onlyPolicy {\n        terms[_id].conclusion = uint48(block.timestamp);\n        markets[_id].capacity = 0;\n        emit CloseMarket(_id);\n    }\n\n    /* ======== EXTERNAL VIEW ======== */\n\n    /**\n     * @notice             payout due for amount of quote tokens\n     * @param _amount      amount of quote tokens to spend\n     * @param _id          ID of market\n     * @return             amount of THEO to be paid in THEO decimals\n     *\n     * @dev 1e18 = theo decimals (9) + fixed bond price decimals (9)\n     */\n    function payoutFor(uint256 _amount, uint256 _id) external view override returns (uint256) {\n        Metadata memory meta = metadata[_id];\n        return (_amount * 1e18) / calculatePrice(_id) / 10**meta.quoteDecimals;\n    }\n\n    /**\n     * @notice             is a given market accepting deposits\n     * @param _id          ID of market\n     */\n    function isLive(uint256 _id) public view override returns (bool) {\n        return (markets[_id].capacity != 0 && terms[_id].conclusion > block.timestamp);\n    }\n\n    /**\n     * @notice returns an array of all active market IDs\n     */\n    function liveMarkets() external view override returns (uint256[] memory) {\n        uint256 num;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) {\n                ids[nonce] = i;\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /**\n     * @notice             returns an array of all active market IDs for a given quote token\n     * @param _token       quote token to check for\n     */\n    function liveMarketsFor(address _token) external view override returns (uint256[] memory) {\n        uint256[] memory mkts = marketsForQuote[_token];\n        uint256 num;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) {\n                ids[nonce] = mkts[i];\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n\n    /**\n     * @notice returns an array of market IDs for historical analysis\n     */\n    function getMarkets() external view override returns (uint256[] memory) {\n        uint256[] memory ids = new uint256[](markets.length);\n        for (uint256 i = 0; i < markets.length; i++) {\n                ids[i] = i;\n        }\n        return ids;\n    }\n\n    /**\n     * @notice             returns an array of all market IDs for a given quote token\n     * @param _token       quote token to check for\n     */\n    function getMarketsFor(address _token) external view override returns (uint256[] memory) {\n        uint256[] memory mkts = marketsForQuote[_token];\n        uint256[] memory ids = new uint256[](mkts.length);\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            ids[i] = mkts[i];\n        }\n        return ids;\n    }\n\n    /**\n     * @notice                  calculate the price of THEO in quote token terms; i.e. the number of quote tokens per THEO\n     * @dev                     get the latest price for the market's quote token in USD\n     *                          (`priceConsumerPrice`, with decimals `priceConsumerDecimals`)\n     *                          then `scalePrice` to scale the fixed bond price to THEO decimals when calculating `price`.\n     *                          finally, calculate `price` as quote tokens per THEO, in THEO decimals (9)\n     * @param _id               market ID\n     * @return                  uint256 price of THEO in quote token terms, in THEO decimals (9)\n     */\n    function calculatePrice(uint256 _id) public view override returns (uint256) {\n        (int256 priceConsumerPrice, uint8 priceConsumerDecimals) = getLatestPrice(markets[_id].priceFeed);\n\n        int256 scaledPrice = scalePrice(int256(markets[_id].usdPricePerTHEO), 9, 9 + priceConsumerDecimals);\n\n        uint256 price = uint256(scaledPrice / priceConsumerPrice);\n        return price;\n    }\n\n    /* ======== INTERNAL PURE ======== */\n\n    /**\n     * @param _price            fixed bond price (USD per THEO), 9 decimals\n     * @param _priceDecimals    decimals (9) used for the fixed bond price\n     * @param _decimals         sum of decimals for THEO token (9) + decimals for the price feed\n     */\n    function scalePrice(\n        int256 _price,\n        uint8 _priceDecimals,\n        uint8 _decimals\n    ) internal pure returns (int256) {\n        if (_priceDecimals < _decimals) {\n            return _price * int256(10**uint256(_decimals - _priceDecimals));\n        } else if (_priceDecimals > _decimals) {\n            return _price / int256(10**uint256(_priceDecimals - _decimals));\n        }\n        return _price;\n    }\n\n    /* ====== POLICY FUNCTIONS ====== */\n\n    function setWethHelper(address _wethHelper) external onlyGovernor {\n        require(_wethHelper != address(0), \"Zero address\");\n        wethHelper = _wethHelper;\n    }\n}\n"
    },
    "src/Types/Signed.sol": {
      "content": "// SPDX-License-Identifier: BSD-3\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport \"./TheopetraAccessControlled.sol\";\n\nabstract contract Signed is TheopetraAccessControlled {\n    using Strings for uint256;\n    using ECDSA for bytes32;\n\n    string private _secret;\n\n    event SetSecret(string secret);\n\n    function setSecret(string calldata secret) external onlyGovernor {\n        _secret = secret;\n        emit SetSecret(secret);\n    }\n\n    function createHash(string memory data) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(address(this), msg.sender, data, _secret));\n    }\n\n    function getSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        return hash.toEthSignedMessageHash().recover(signature);\n    }\n\n    function isAuthorizedSigner(address extracted) internal view virtual returns (bool) {\n        return extracted == authority.whitelistSigner();\n    }\n\n    function verifySignature(string memory data, bytes calldata signature) internal view {\n        address extracted = getSigner(createHash(data), signature);\n        require(isAuthorizedSigner(extracted), \"Signature verification failed\");\n    }\n}\n"
    },
    "src/Types/PriceConsumerV3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract PriceConsumerV3 {\n    /**\n     * Returns the latest price\n     */\n    function getLatestPrice(address priceFeedAddress) public view returns (int256, uint8) {\n        (\n            uint80 roundID,\n            int256 price,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(priceFeedAddress).latestRoundData();\n\n        uint8 decimals = AggregatorV3Interface(priceFeedAddress).decimals();\n\n        return (price, decimals);\n    }\n}\n"
    },
    "src/Interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/Interfaces/IWhitelistBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IWhitelistBondDepository {\n    /**\n     * @notice      Info about each type of market\n     * @dev         Market::capacity is capacity remaining\n     *              Market::quoteToken is token to accept as payment\n     *              Market::priceFeed is address of the price consumer, to return the USD value for the quote token when deposits are made\n     *              Market::capacityInQuote is in payment token (true) or in THEO (false, default)\n     *              Market::sold is base tokens out\n     *              Market::purchased quote tokens in\n     *              Market::usdPricePerTHEO is 9 decimal USD value for each THEO bond\n     */\n    struct Market {\n        uint256 capacity;\n        IERC20 quoteToken;\n        address priceFeed;\n        bool capacityInQuote;\n        uint64 sold;\n        uint256 purchased;\n        uint256 usdPricePerTHEO;\n    }\n\n    /**\n     * @notice      Info for creating new markets\n     * @dev         Terms::fixedTerm is fixed term or fixed expiration\n     *              Terms::vesting is length of time from deposit to maturity if fixed-term\n     *              Terms::conclusion is timestamp when market no longer offered (doubles as time when market matures if fixed-expiry)\n     */\n    struct Terms {\n        bool fixedTerm;\n        uint48 vesting;\n        uint48 conclusion;\n    }\n\n    /**\n     * @notice      Additional info about market\n     * @dev         Metadata::quoteDecimals is decimals of quote token\n     */\n    struct Metadata {\n        uint8 quoteDecimals;\n    }\n\n    struct DepositInfo {\n        uint256 payout_;\n        uint256 expiry_;\n        uint256 index_;\n    }\n\n    /**\n     * @notice deposit market\n     * @param _bid uint256\n     * @param _amount uint256\n     * @param _maxPrice uint256\n     * @param _user address\n     * @param _referral address\n     * @param signature bytes\n     * @return depositInfo DepositInfo\n     */\n    function deposit(\n        uint256 _bid,\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _user,\n        address _referral,\n        bytes calldata signature\n    ) external returns (DepositInfo memory depositInfo);\n\n    /**\n     * @notice create market\n     * @param _quoteToken IERC20 is the token used to deposit\n     * @param _priceFeed address is address of the price consumer, to return the USD value for the quote token when deposits are made\n     * @param _market uint256[2] is [capacity, fixed bond price (9 decimals) USD per THEO]\n     * @param _booleans bool[2] is [capacity in quote, fixed term]\n     * @param _terms uint256[2] is [vesting, conclusion]\n     * @return id_ uint256 is ID of the market\n     */\n    function create(\n        IERC20 _quoteToken,\n        address _priceFeed,\n        uint256[2] memory _market,\n        bool[2] memory _booleans,\n        uint256[2] memory _terms\n    ) external returns (uint256 id_);\n\n    function close(uint256 _id) external;\n\n    function isLive(uint256 _bid) external view returns (bool);\n\n    function liveMarkets() external view returns (uint256[] memory);\n\n    function liveMarketsFor(address _quoteToken) external view returns (uint256[] memory);\n\n    function getMarkets() external view returns (uint256[] memory);\n\n    function getMarketsFor(address _quoteToken) external view returns (uint256[] memory);\n\n    function calculatePrice(uint256 _bid) external view returns (uint256);\n\n    function payoutFor(uint256 _amount, uint256 _bid) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "src/Theopetra/WethHelper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"../Interfaces/IWETH9.sol\";\nimport \"../Interfaces/IBondDepository.sol\";\nimport \"../Interfaces/IWhitelistBondDepository.sol\";\n\nimport \"../Types/Signed.sol\";\n\ncontract WethHelper is Signed {\n    IWETH9 public weth;\n    IBondDepository public bondDepo;\n    IWhitelistBondDepository public whitelistBondDepo;\n    IWhitelistBondDepository public publicPreListBondDepo;\n\n    constructor(\n        address _weth,\n        ITheopetraAuthority _authority,\n        address _bondDepo,\n        address _whitelistBondDepo\n    ) TheopetraAccessControlled(_authority) {\n        weth = IWETH9(_weth);\n        bondDepo = IBondDepository(_bondDepo);\n        whitelistBondDepo = IWhitelistBondDepository(_whitelistBondDepo);\n    }\n\n    /**\n     * @notice             Deposit to WETH, and subsequently deposit to the relevant Bond Depository\n     * @dev                When the address of the Public Pre-List bond depository is non-zero (as set by `setPublicPreList`),\n     *                     and `_isWhitelist` is true, then `deposit` will be called on the Public Pre-List\n     *                     (as oposed to the Private Whitelist bond depository)\n     * @param _id          the id of the bond market into which a deposit should be made\n     * @param _maxPrice    the maximum price at which to buy\n     * @param _user        the recipient of the payout\n     * @param _referral    the front end operator address\n     * @param _autoStake   bool, true if the payout should be automatically staked (this value is not used by the whitelist bond depository)\n     * @param _isWhitelist bool, true if the bond depository is the whitelist bond depo or public pre-list bond depo\n     * @param signature    the signature for verification of a whitelisted depositor\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _maxPrice,\n        address _user,\n        address _referral,\n        bool _autoStake,\n        bool _isWhitelist,\n        bytes calldata signature\n    ) public payable {\n        require(msg.value > 0, \"No value\");\n\n        weth.deposit{ value: msg.value }();\n\n        if (_isWhitelist && address(publicPreListBondDepo) == address(0)) {\n            verifySignature(\"\", signature);\n            weth.approve(address(whitelistBondDepo), msg.value);\n            whitelistBondDepo.deposit(_id, msg.value, _maxPrice, _user, _referral, signature);\n        } else if (_isWhitelist) {\n            weth.approve(address(publicPreListBondDepo), msg.value);\n            publicPreListBondDepo.deposit(_id, msg.value, _maxPrice, _user, _referral, signature);\n        } else {\n            weth.approve(address(bondDepo), msg.value);\n            bondDepo.deposit(_id, msg.value, _maxPrice, _user, _referral, _autoStake);\n        }\n    }\n\n    /**\n     * @notice             Set the address of the Public Pre-List Bond Depository\n     * @dev                After setting to a non-zero address, calls to the `deposit` method with\n     *                     `_isWhitelist` == true will result in deposits being made to the Public Pre-List bond depository\n     *                     (as oposed to the Private Whitelist bond depository)\n     *                     See also `deposit` method\n     * @param _publicPreList          the address of the Public Pre-List Bond Depository Contract\n     */\n    function setPublicPreList(address _publicPreList) external onlyGovernor {\n        publicPreListBondDepo = IWhitelistBondDepository(_publicPreList);\n    }\n}\n"
    },
    "src/Interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\ninterface IWETH9 {\n    function deposit() external payable;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n}\n"
    },
    "src/Interfaces/IBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IBondDepository {\n    // Info about each type of market\n    struct Market {\n        uint256 capacity; // capacity remaining\n        IERC20 quoteToken; // token to accept as payment\n        bool capacityInQuote; // capacity limit is in payment token (true) or in THEO (false, default)\n        uint256 sold; // base tokens out\n        uint256 purchased; // quote tokens in\n        uint256 totalDebt; // total debt from market\n        uint256 maxPayout; // max tokens in/out (determined by capacityInQuote false/true, respectively)\n    }\n\n    // Info for creating new markets\n    struct Terms {\n        bool fixedTerm; // fixed term or fixed expiration\n        uint48 vesting; // length of time from deposit to maturity if fixed-term\n        uint48 conclusion; // timestamp when market no longer offered (doubles as time when market matures if fixed-expiry)\n        int64 bondRateFixed; // 9 decimal fixed discount expressed as a proportion (that is, a percentage in its decimal form)\n        int64 maxBondRateVariable; // 9 decimal maximum proportion (that is, a percentage in its decimal form) discount on current market price\n        int64 discountRateBond; // 9 decimal\n        int64 discountRateYield; // 9 decimal\n        uint256 maxDebt; // 9 decimal debt maximum in THEO\n    }\n\n    // Additional info about market.\n    struct Metadata {\n        uint48 lastTune; // last timestamp when control variable was tuned\n        uint48 lastDecay; // last timestamp when market was created and debt was decayed\n        uint48 length; // time from creation to conclusion. used as speed to decay debt.\n        uint64 depositInterval; // target frequency of deposits\n        uint64 tuneInterval; // frequency of tuning\n        uint8 quoteDecimals; // decimals of quote token\n    }\n\n    struct DepositArgs {\n        uint256 id;\n        uint256 amount;\n        uint256 maxPrice;\n        address user;\n        address referral;\n        bool autoStake;\n    }\n\n    /**\n     * @notice deposit market\n     * @param _bid uint256\n     * @param _amount uint256\n     * @param _maxPrice uint256\n     * @param _user address\n     * @param _referral address\n     * @return payout_ uint256\n     * @return expiry_ uint256\n     * @return index_ uint256\n     */\n    function deposit(\n        uint256 _bid,\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _user,\n        address _referral,\n        bool _autoStake\n    )\n        external\n        returns (\n            uint256 payout_,\n            uint256 expiry_,\n            uint256 index_\n        );\n\n    function create(\n        IERC20 _quoteToken, // token used to deposit\n        uint256[3] memory _market, // [capacity, initial price]\n        bool[2] memory _booleans, // [capacity in quote, fixed term]\n        uint256[2] memory _terms, // [vesting, conclusion]\n        int64[4] memory _rates, // [bondRateFixed, maxBondRateVariable, initial discountRateBond (Drb), initial discountRateYield (Dyb)]\n        uint64[2] memory _intervals // [deposit interval, tune interval]\n    ) external returns (uint256 id_);\n\n    function close(uint256 _id) external;\n\n    function isLive(uint256 _bid) external view returns (bool);\n\n    function liveMarkets() external view returns (uint256[] memory);\n\n    function liveMarketsFor(address _quoteToken) external view returns (uint256[] memory);\n\n    function getMarkets() external view returns (uint256[] memory);\n\n    function getMarketsFor(address _quoteToken) external view returns (uint256[] memory);\n\n    function payoutFor(uint256 _amount, uint256 _bid) external view returns (uint256);\n\n    function marketPrice(uint256 _bid) external view returns (uint256);\n\n    function currentDebt(uint256 _bid) external view returns (uint256);\n\n    function debtDecay(uint256 _bid) external view returns (uint64);\n\n    function setDiscountRateBond(uint256 _id, int64 _discountRateBond) external;\n\n    function setDiscountRateYield(uint256 _id, int64 _discountRateYield) external;\n\n    function bondRateVariable(uint256 _id) external view returns (uint256);\n}\n"
    },
    "src/Theopetra/PublicPreListBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"../Types/NoteKeeper.sol\";\nimport \"../Types/Signed.sol\";\nimport \"../Types/PriceConsumerV3.sol\";\n\nimport \"../Libraries/SafeERC20.sol\";\n\nimport \"../Interfaces/IERC20Metadata.sol\";\nimport \"../Interfaces/IWhitelistBondDepository.sol\";\n\n/**\n * @title Theopetra Public Pre-List Bond Depository\n * @notice Based off of WhitelistTheopetraBondDepository, with the call to `verifySignature` removed,\n *         as well as the function `setWethHelper` and state variable `wethHelper` removed\n */\n\ncontract PublicPreListBondDepository is IWhitelistBondDepository, NoteKeeper, Signed, PriceConsumerV3 {\n    /* ======== DEPENDENCIES ======== */\n\n    using SafeERC20 for IERC20;\n\n    /* ======== EVENTS ======== */\n\n    event CreateMarket(\n        uint256 indexed id,\n        address indexed baseToken,\n        address indexed quoteToken,\n        uint256 fixedBondPrice\n    );\n    event CloseMarket(uint256 indexed id);\n    event Bond(uint256 indexed id, uint256 amount, uint256 price);\n\n    /* ======== STATE VARIABLES ======== */\n\n    // Storage\n    Market[] public markets; // persistent market data\n    Terms[] public terms; // deposit construction data\n    Metadata[] public metadata; // extraneous market data\n\n    // Queries\n    mapping(address => uint256[]) public marketsForQuote; // market IDs for quote token\n\n    /* ======== CONSTRUCTOR ======== */\n\n    constructor(\n        ITheopetraAuthority _authority,\n        IERC20 _theo,\n        IStakedTHEOToken _stheo,\n        IStaking _staking,\n        ITreasury _treasury\n    ) NoteKeeper(_authority, _theo, _stheo, _staking, _treasury) {\n        // save gas for users by bulk approving stake() transactions\n        _theo.approve(address(_staking), 1e45);\n    }\n\n    /* ======== DEPOSIT ======== */\n\n    /**\n     * @notice             deposit quote tokens in exchange for a bond from a specified market\n     * @param _id          the ID of the market\n     * @param _amount      the amount of quote token to spend\n     * @param _maxPrice    the maximum price at which to buy\n     * @param _user        the recipient of the payout\n     * @param _referral    the front end operator address\n     * @return depositInfo DepositInfo\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _user,\n        address _referral,\n        bytes calldata signature\n    ) external override returns (DepositInfo memory depositInfo) {\n        Market storage market = markets[_id];\n        Terms memory term = terms[_id];\n        uint48 currentTime = uint48(block.timestamp);\n\n        // Markets end at a defined timestamp\n        // |-------------------------------------| t\n        require(currentTime < term.conclusion, \"Depository: market concluded\");\n\n        // Get the price of THEO in quote token terms\n        // i.e. the number of quote tokens per THEO\n        // With 9 decimal places\n        uint256 price = calculatePrice(_id);\n\n        // Users input a maximum price, which protects them from price changes after\n        // entering the mempool. max price is a slippage mitigation measure\n        require(price <= _maxPrice, \"Depository: more than max price\");\n\n        /**\n         * payout for the deposit = amount / price\n         *\n         * where\n         * payout = THEO out, in THEO decimals (9)\n         * amount = quote tokens in\n         * price = quote tokens per THEO, in THEO decimals (9)\n         *\n         * 1e18 = THEO decimals (9) + price decimals (9)\n         */\n        depositInfo.payout_ = ((_amount * 1e18) / price) / (10**metadata[_id].quoteDecimals);\n\n        /*\n         * each market is initialized with a capacity\n         *\n         * this is either the number of THEO that the market can sell\n         * (if capacity in quote is false),\n         *\n         * or the number of quote tokens that the market can buy\n         * (if capacity in quote is true)\n         */\n\n        require(\n            market.capacity >= (market.capacityInQuote ? _amount : depositInfo.payout_),\n            \"Depository: capacity exceeded\"\n        );\n\n        market.capacity -= market.capacityInQuote ? _amount : depositInfo.payout_;\n\n        if (market.capacity == 0) {\n            emit CloseMarket(_id);\n        }\n\n        /**\n         * bonds mature with a cliff at a set timestamp\n         * prior to the expiry timestamp, no payout tokens are accessible to the user\n         * after the expiry timestamp, the entire payout can be redeemed\n         *\n         * there are two types of bonds: fixed-term and fixed-expiration\n         *\n         * fixed-term bonds mature in a set amount of time from deposit\n         * i.e. term = 1 week. when alice deposits on day 1, her bond\n         * expires on day 8. when bob deposits on day 2, his bond expires day 9.\n         *\n         * fixed-expiration bonds mature at a set timestamp\n         * i.e. expiration = day 10. when alice deposits on day 1, her term\n         * is 9 days. when bob deposits on day 2, his term is 8 days.\n         */\n        depositInfo.expiry_ = term.fixedTerm ? term.vesting + currentTime : term.vesting;\n\n        // markets keep track of how many quote tokens have been\n        // purchased, and how much THEO has been sold\n        market.purchased += _amount;\n        market.sold += uint64(depositInfo.payout_);\n\n        emit Bond(_id, _amount, price);\n\n        /**\n         * user data is stored as Notes. these are isolated array entries\n         * storing the amount due, the time created, the time when payout\n         * is redeemable, the time when payout was redeemed, and the ID\n         * of the market deposited into\n         */\n        depositInfo.index_ = addNote(\n            _user,\n            depositInfo.payout_,\n            uint48(depositInfo.expiry_),\n            uint48(_id),\n            _referral,\n            0,\n            false\n        );\n\n        // transfer payment to treasury\n        market.quoteToken.safeTransferFrom(msg.sender, address(treasury), _amount);\n    }\n\n    /* ======== CREATE ======== */\n\n    /**\n     * @notice             creates a new market type\n     * @dev                current price should be in 9 decimals.\n     * @param _quoteToken  token used to deposit\n     * @param _market      [capacity (in THEO or quote), fixed bond price (9 decimals) USD per THEO]\n     * @param _booleans    [capacity in quote, fixed term]\n     * @param _terms       [vesting length (if fixed term) or vested timestamp, conclusion timestamp]\n     * @param _priceFeed   address of the price consumer, to return the USD value for the quote token when deposits are made\n     * @return id_         ID of new bond market\n     */\n    function create(\n        IERC20 _quoteToken,\n        address _priceFeed,\n        uint256[2] memory _market,\n        bool[2] memory _booleans,\n        uint256[2] memory _terms\n    ) external override onlyPolicy returns (uint256 id_) {\n        // the decimal count of the quote token\n        uint256 decimals = IERC20Metadata(address(_quoteToken)).decimals();\n\n        // depositing into, or getting info for, the created market uses this ID\n        id_ = markets.length;\n\n        markets.push(\n            Market({\n                quoteToken: _quoteToken,\n                priceFeed: _priceFeed,\n                capacityInQuote: _booleans[0],\n                capacity: _market[0],\n                purchased: 0,\n                sold: 0,\n                usdPricePerTHEO: _market[1]\n            })\n        );\n\n        terms.push(Terms({ fixedTerm: _booleans[1], vesting: uint48(_terms[0]), conclusion: uint48(_terms[1]) }));\n\n        metadata.push(Metadata({ quoteDecimals: uint8(decimals) }));\n\n        marketsForQuote[address(_quoteToken)].push(id_);\n\n        emit CreateMarket(id_, address(theo), address(_quoteToken), _market[1]);\n    }\n\n    /**\n     * @notice             disable existing market\n     * @param _id          ID of market to close\n     */\n    function close(uint256 _id) external override onlyPolicy {\n        terms[_id].conclusion = uint48(block.timestamp);\n        markets[_id].capacity = 0;\n        emit CloseMarket(_id);\n    }\n\n    /* ======== EXTERNAL VIEW ======== */\n\n    /**\n     * @notice             payout due for amount of quote tokens\n     * @param _amount      amount of quote tokens to spend\n     * @param _id          ID of market\n     * @return             amount of THEO to be paid in THEO decimals\n     *\n     * @dev 1e18 = theo decimals (9) + fixed bond price decimals (9)\n     */\n    function payoutFor(uint256 _amount, uint256 _id) external view override returns (uint256) {\n        Metadata memory meta = metadata[_id];\n        return (_amount * 1e18) / calculatePrice(_id) / 10**meta.quoteDecimals;\n    }\n\n    /**\n     * @notice             is a given market accepting deposits\n     * @param _id          ID of market\n     */\n    function isLive(uint256 _id) public view override returns (bool) {\n        return (markets[_id].capacity != 0 && terms[_id].conclusion > block.timestamp);\n    }\n\n    /**\n     * @notice returns an array of all active market IDs\n     */\n    function liveMarkets() external view override returns (uint256[] memory) {\n        uint256 num;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) {\n                ids[nonce] = i;\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /**\n     * @notice             returns an array of all active market IDs for a given quote token\n     * @param _token       quote token to check for\n     */\n    function liveMarketsFor(address _token) external view override returns (uint256[] memory) {\n        uint256[] memory mkts = marketsForQuote[_token];\n        uint256 num;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) {\n                ids[nonce] = mkts[i];\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /**\n     * @notice returns an array of market IDs for historical analysis\n     */\n    function getMarkets() external view override returns (uint256[] memory) {\n        uint256[] memory ids = new uint256[](markets.length);\n        for (uint256 i = 0; i < markets.length; i++) {\n                ids[i] = i;\n        }\n        return ids;\n    }\n\n    /**\n     * @notice             returns an array of all market IDs for a given quote token\n     * @param _token       quote token to check for\n     */\n    function getMarketsFor(address _token) external view override returns (uint256[] memory) {\n        uint256[] memory mkts = marketsForQuote[_token];\n        uint256[] memory ids = new uint256[](mkts.length);\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            ids[i] = mkts[i];\n        }\n        return ids;\n    }\n\n    /**\n     * @notice                  calculate the price of THEO in quote token terms; i.e. the number of quote tokens per THEO\n     * @dev                     get the latest price for the market's quote token in USD\n     *                          (`priceConsumerPrice`, with decimals `priceConsumerDecimals`)\n     *                          then `scalePrice` to scale the fixed bond price to THEO decimals when calculating `price`.\n     *                          finally, calculate `price` as quote tokens per THEO, in THEO decimals (9)\n     * @param _id               market ID\n     * @return                  uint256 price of THEO in quote token terms, in THEO decimals (9)\n     */\n    function calculatePrice(uint256 _id) public view override returns (uint256) {\n        (int256 priceConsumerPrice, uint8 priceConsumerDecimals) = getLatestPrice(markets[_id].priceFeed);\n\n        int256 scaledPrice = scalePrice(int256(markets[_id].usdPricePerTHEO), 9, 9 + priceConsumerDecimals);\n\n        uint256 price = uint256(scaledPrice / priceConsumerPrice);\n        return price;\n    }\n\n    /* ======== INTERNAL PURE ======== */\n\n    /**\n     * @param _price            fixed bond price (USD per THEO), 9 decimals\n     * @param _priceDecimals    decimals (9) used for the fixed bond price\n     * @param _decimals         sum of decimals for THEO token (9) + decimals for the price feed\n     */\n    function scalePrice(\n        int256 _price,\n        uint8 _priceDecimals,\n        uint8 _decimals\n    ) internal pure returns (int256) {\n        if (_priceDecimals < _decimals) {\n            return _price * int256(10**uint256(_decimals - _priceDecimals));\n        } else if (_priceDecimals > _decimals) {\n            return _price / int256(10**uint256(_priceDecimals - _decimals));\n        }\n        return _price;\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "src/Theopetra/BondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../Types/NoteKeeper.sol\";\n\nimport \"../Libraries/SafeERC20.sol\";\n\nimport \"../Interfaces/IERC20Metadata.sol\";\nimport \"../Interfaces/IBondDepository.sol\";\nimport \"../Interfaces/ITreasury.sol\";\nimport \"../Interfaces/IBondCalculator.sol\";\n\n/**\n * @title Theopetra Bond Depository\n * @notice Originally based off of Olympus Bond Depository V2\n */\n\ncontract TheopetraBondDepository is IBondDepository, NoteKeeper {\n    /* ======== DEPENDENCIES ======== */\n\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    /* ======== EVENTS ======== */\n\n    event CreateMarket(uint256 indexed id, address indexed baseToken, address indexed quoteToken, uint256 initialPrice);\n    event CloseMarket(uint256 indexed id);\n    event Bond(uint256 indexed id, uint256 amount, uint256 price);\n    event SetDYB(uint256 indexed id, int64 dYB);\n    event SetDRB(uint256 indexed id, int64 dRB);\n\n    /* ======== STATE VARIABLES ======== */\n\n    // Storage\n    Market[] public markets; // persistent market data\n    Terms[] public terms; // deposit construction data\n    Metadata[] public metadata; // extraneous market data\n\n    // Queries\n    mapping(address => uint256[]) public marketsForQuote; // market IDs for quote token\n\n    /* ======== STRUCTS ======== */\n\n    struct PriceInfo {\n        uint256 price;\n        uint48 bondRateVariable;\n    }\n\n    /* ======== CONSTRUCTOR ======== */\n\n    constructor(\n        ITheopetraAuthority _authority,\n        IERC20 _theo,\n        IStakedTHEOToken _stheo,\n        IStaking _staking,\n        ITreasury _treasury\n    ) NoteKeeper(_authority, _theo, _stheo, _staking, _treasury) {\n        // save gas for users by bulk approving stake() transactions\n        _theo.approve(address(_staking), 1e45);\n    }\n\n    /* ======== DEPOSIT ======== */\n\n    /**\n     * @notice             deposit quote tokens in exchange for a bond from a specified market\n     * @param _id          the ID of the market\n     * @param _amount      the amount of quote token to spend\n     * @param _maxPrice    the maximum price at which to buy\n     * @param _user        the recipient of the payout\n     * @param _referral    the front end operator address\n     * @return payout_     the amount of sTHEO due\n     * @return expiry_     the timestamp at which payout is redeemable\n     * @return index_      the user index of the Note (used to redeem or query information)\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _user,\n        address _referral,\n        bool _autoStake\n    )\n        external\n        override\n        returns (\n            uint256 payout_,\n            uint256 expiry_,\n            uint256 index_\n        )\n    {\n        // prevent \"stack too deep\"\n        DepositArgs memory depositInfo = DepositArgs(_id, _amount, _maxPrice, _user, _referral, _autoStake);\n\n        Market storage market = markets[depositInfo.id];\n        Terms memory term = terms[depositInfo.id];\n        PriceInfo memory priceInfo;\n        uint48 currentTime = uint48(block.timestamp);\n\n        // Markets end at a defined timestamp\n        // |-------------------------------------| t\n        require(currentTime < term.conclusion, \"Depository: market concluded\");\n\n        // Debt decays over time\n        _decay(depositInfo.id, currentTime);\n\n        // Users input a maximum price, which protects them from price changes after\n        // entering the mempool. max price is a slippage mitigation measure\n        priceInfo.price = marketPrice(depositInfo.id);\n        require(priceInfo.price <= depositInfo.maxPrice, \"Depository: more than max price\");\n        /**\n         * payout for the deposit = amount / price\n         *\n         * where\n         * payout = THEO out\n         * amount = quote tokens in\n         * price = quote tokens : theo (i.e. 42069 DAI : THEO)\n         *\n         * 1e18 = THEO decimals (9) + price decimals (9)\n         */\n        payout_ = ((depositInfo.amount * 1e18) / priceInfo.price) / (10**metadata[depositInfo.id].quoteDecimals);\n\n        // markets have a max payout amount, capping size because deposits\n        // do not experience slippage. max payout is recalculated upon tuning\n        require(payout_ <= market.maxPayout, \"Depository: max size exceeded\");\n\n        /*\n         * each market is initialized with a capacity\n         *\n         * this is either the number of THEO that the market can sell\n         * (if capacity in quote is false),\n         *\n         * or the number of quote tokens that the market can buy\n         * (if capacity in quote is true)\n         */\n        market.capacity -= market.capacityInQuote ? depositInfo.amount : payout_;\n\n        /**\n         * bonds mature with a cliff at a set timestamp\n         * prior to the expiry timestamp, no payout tokens are accessible to the user\n         * after the expiry timestamp, the entire payout can be redeemed\n         *\n         * there are two types of bonds: fixed-term and fixed-expiration\n         *\n         * fixed-term bonds mature in a set amount of time from deposit\n         * i.e. term = 1 week. when alice deposits on day 1, her bond\n         * expires on day 8. when bob deposits on day 2, his bond expires day 9.\n         *\n         * fixed-expiration bonds mature at a set timestamp\n         * i.e. expiration = day 10. when alice deposits on day 1, her term\n         * is 9 days. when bob deposits on day 2, his term is 8 days.\n         */\n        expiry_ = term.fixedTerm ? term.vesting + currentTime : term.vesting;\n\n        // markets keep track of how many quote tokens have been\n        // purchased, and how much THEO has been sold\n        market.purchased += depositInfo.amount;\n        market.sold += payout_;\n\n        // increment total debt, which is later compared to maxDebt (this can be a circuit-breaker)\n        market.totalDebt += payout_;\n\n        emit Bond(depositInfo.id, depositInfo.amount, priceInfo.price);\n\n        /**\n         * user data is stored as Notes. these are isolated array entries\n         * storing the amount due, the time created, the time when payout\n         * is redeemable, the time when payout was redeemed, the ID\n         * of the market deposited into, and the Bond Rate Variable (Brv) discount on the bond\n         */\n        priceInfo.bondRateVariable = uint48(bondRateVariable(depositInfo.id));\n        index_ = addNote(\n            depositInfo.user,\n            payout_,\n            uint48(expiry_),\n            uint48(depositInfo.id),\n            depositInfo.referral,\n            priceInfo.bondRateVariable,\n            depositInfo.autoStake\n        );\n\n        // transfer payment to treasury\n        market.quoteToken.safeTransferFrom(msg.sender, address(treasury), depositInfo.amount);\n\n        // if max debt is breached, the market is closed\n        // this a circuit breaker\n        if (term.maxDebt < market.totalDebt) {\n            market.capacity = 0;\n            emit CloseMarket(depositInfo.id);\n        } else {\n            // if market will continue, the control variable is tuned to hit targets on time\n            _tune(depositInfo.id, currentTime);\n        }\n    }\n\n    /**\n     * @notice             decay debt, and adjust control variable if there is an active change\n     * @param _id          ID of market\n     * @param _time        uint48 timestamp (saves gas when passed in)\n     */\n    function _decay(uint256 _id, uint48 _time) internal {\n        // Debt decay\n\n        /*\n         * Debt is a time-decayed sum of tokens spent in a market\n         * Debt is added when deposits occur and removed over time\n         * |\n         * |    debt falls with\n         * |   / \\  inactivity       / \\\n         * | /     \\              /\\/    \\\n         * |         \\           /         \\\n         * |           \\      /\\/            \\\n         * |             \\  /  and rises       \\\n         * |                with deposits\n         * |\n         * |------------------------------------| t\n         */\n        markets[_id].totalDebt -= debtDecay(_id);\n        metadata[_id].lastDecay = _time;\n    }\n\n    /**\n     * @notice          adjust the market's maxPayout\n     * @dev             calculate the correct payout to complete on time assuming each bond\n     *                  will be max size in the desired deposit interval for the remaining time\n     *                  i.e. market has 10 days remaining. deposit interval is 1 day. capacity\n     *                  is 10,000 THEO. max payout would be 1,000 THEO (10,000 * 1 / 10).\n     * @param _id       ID of market\n     * @param _time     uint48 timestamp (saves gas when passed in)\n     */\n    function _tune(uint256 _id, uint48 _time) internal {\n        Metadata memory meta = metadata[_id];\n\n        if (_time >= meta.lastTune + meta.tuneInterval) {\n            Market memory market = markets[_id];\n\n            // compute seconds remaining until market will conclude\n            uint256 timeRemaining = terms[_id].conclusion - _time;\n            uint256 price = marketPrice(_id);\n\n            // standardize capacity into a base token amount\n            // theo decimals (9) + price decimals (9)\n            uint256 capacity = market.capacityInQuote\n                ? ((market.capacity * 1e18) / price) / (10**meta.quoteDecimals)\n                : market.capacity;\n\n            markets[_id].maxPayout = uint256((capacity * meta.depositInterval) / timeRemaining);\n\n            metadata[_id].lastTune = _time;\n        }\n    }\n\n    /* ======== CREATE ======== */\n\n    /**\n     * @notice             creates a new market type\n     * @dev                current price should be in 9 decimals.\n     * @param _quoteToken  token used to deposit\n     * @param _market      [capacity (in THEO or quote), initial price / THEO (9 decimals), debt buffer (3 decimals)]\n     * @param _booleans    [capacity in quote, fixed term]\n     * @param _terms       [vesting length (if fixed term) or vested timestamp, conclusion timestamp]\n     * @param _rates       [bondRateFixed, maxBondRateVariable, initial discountRateBond (Drb), initial discountRateYield (Dyb)]\n     * @param _intervals   [deposit interval (seconds), tune interval (seconds)]\n     * @return id_         ID of new bond market\n     */\n    function create(\n        IERC20 _quoteToken,\n        uint256[3] memory _market,\n        bool[2] memory _booleans,\n        uint256[2] memory _terms,\n        int64[4] memory _rates,\n        uint64[2] memory _intervals\n    ) external override onlyPolicy returns (uint256 id_) {\n        // the length of the program, in seconds\n        uint256 secondsToConclusion = _terms[1] - block.timestamp;\n\n        // the decimal count of the quote token\n        uint256 decimals = IERC20Metadata(address(_quoteToken)).decimals();\n\n        /*\n         * initial target debt is equal to capacity (this is the amount of debt\n         * that will decay over in the length of the program if price remains the same).\n         * it is converted into base token terms if passed in in quote token terms.\n         *\n         * 1e18 = theo decimals (9) + initial price decimals (9)\n         */\n        uint256 targetDebt = uint256(_booleans[0] ? ((_market[0] * 1e18) / _market[1]) / 10**decimals : _market[0]);\n\n        /*\n         * max payout is the amount of capacity that should be utilized in a deposit\n         * interval. for example, if capacity is 1,000 THEO, there are 10 days to conclusion,\n         * and the preferred deposit interval is 1 day, max payout would be 100 THEO.\n         */\n        uint256 maxPayout = (targetDebt * _intervals[0]) / secondsToConclusion;\n\n        /*\n         * max debt serves as a circuit breaker for the market. let's say the quote\n         * token is a stablecoin, and that stablecoin depegs. without max debt, the\n         * market would continue to buy until it runs out of capacity. this is\n         * configurable with a 3 decimal buffer (1000 = 1% above initial price).\n         * note that its likely advisable to keep this buffer wide.\n         * note that the buffer is above 100%. i.e. 10% buffer = initial debt * 1.1\n         */\n        uint256 maxDebt = targetDebt + ((targetDebt * _market[2]) / 1e5); // 1e5 = 100,000. 10,000 / 100,000 = 10%.\n\n        // depositing into, or getting info for, the created market uses this ID\n        id_ = markets.length;\n\n        markets.push(\n            Market({\n                quoteToken: _quoteToken,\n                capacityInQuote: _booleans[0],\n                capacity: _market[0],\n                totalDebt: targetDebt,\n                maxPayout: maxPayout,\n                purchased: 0,\n                sold: 0\n            })\n        );\n\n        terms.push(\n            Terms({\n                fixedTerm: _booleans[1],\n                vesting: uint48(_terms[0]),\n                conclusion: uint48(_terms[1]),\n                bondRateFixed: int64(_rates[0]),\n                maxBondRateVariable: int64(_rates[1]),\n                discountRateBond: int64(_rates[2]),\n                discountRateYield: int64(_rates[3]),\n                maxDebt: maxDebt\n            })\n        );\n\n        metadata.push(\n            Metadata({\n                lastTune: uint48(block.timestamp),\n                lastDecay: uint48(block.timestamp),\n                length: uint48(secondsToConclusion),\n                depositInterval: uint64(_intervals[0]),\n                tuneInterval: uint64(_intervals[1]),\n                quoteDecimals: uint8(decimals)\n            })\n        );\n\n        marketsForQuote[address(_quoteToken)].push(id_);\n\n        emit CreateMarket(id_, address(theo), address(_quoteToken), _market[1]);\n    }\n\n    /**\n     * @notice             disable existing market\n     * @param _id          ID of market to close\n     */\n    function close(uint256 _id) external override onlyPolicy {\n        terms[_id].conclusion = uint48(block.timestamp);\n        markets[_id].capacity = 0;\n        emit CloseMarket(_id);\n    }\n\n    /* ======== BONDING RATES ======== */\n\n    /**\n     * @notice                      update the Discount Rate Return Bond (Drb) for a specified market\n     * @param _id                   uint256 the ID of the bond market to update\n     * @param _discountRateBond     uint64 the new Discount Rate Return Bond (Drb), 9 decimals\n     */\n    function setDiscountRateBond(uint256 _id, int64 _discountRateBond) external override onlyPolicy {\n        terms[_id].discountRateBond = _discountRateBond;\n        emit SetDRB(_id, _discountRateBond);\n    }\n\n    /**\n     * @notice                      update the Discount Rate Return Yield (Dyb) for a specified market\n     * @param _id                   uint256 the ID of the bond market to update\n     * @param _discountRateYield    uint64 the new Discount Rate Return Yield (Dyb), 9 decimals\n     */\n    function setDiscountRateYield(uint256 _id, int64 _discountRateYield) external override onlyPolicy {\n        terms[_id].discountRateYield = _discountRateYield;\n        emit SetDYB(_id, _discountRateYield);\n    }\n\n    /**\n     * @notice                  calculate bond rate variable (Brv)\n     * @dev                     see marketPrice for calculation details.\n     * @param _id               ID of market\n     */\n    function bondRateVariable(uint256 _id) public view override returns (uint256) {\n        int256 bondRateVariable = int64(terms[_id].bondRateFixed) +\n            ((int64(terms[_id].discountRateBond) * ITreasury(treasury).deltaTokenPrice()) / 10**9) + //deltaTokenPrice is 9 decimals\n            ((int64(terms[_id].discountRateYield) * ITreasury(treasury).deltaTreasuryYield()) / 10**9); // deltaTreasuryYield is 9 decimals\n\n        if (bondRateVariable <= 0) {\n            return 0;\n        } else if (bondRateVariable >= terms[_id].maxBondRateVariable) {\n            return uint256(uint64(terms[_id].maxBondRateVariable));\n        } else {\n            return bondRateVariable.toUint256();\n        }\n    }\n\n    /* ======== EXTERNAL VIEW ======== */\n\n    /**\n     * @notice             calculate current market price of quote token in base token (i.e. quote tokens per THEO)\n     * @dev                uses the theoBondingCalculator.valuation method (using an amount of 1) to get the quote token value (Quote-Token per THEO).\n     * @param _id          ID of market\n     * @return             price for market in THEO decimals\n     *\n     * price is derived from the equation\n     *\n     * P = Cmv * (1 - Brv)\n     *\n     * where\n     * p = price\n     * cmv = current market value\n     * Brv = bond rate, variable. This is a proportion (that is, a percentage in its decimal form), with 9 decimals\n     *\n     * Brv = Brf + Bcrb + Bcyb\n     *\n     * where\n     * Brf = bond rate, fixed\n     * Bcrb = Drb * deltaTokenPrice\n     * Bcyb = Dyb * deltaTreasuryYield\n     *\n     *\n     * where\n     * Drb is a discount rate as a proportion (that is, a percentage in its decimal form) applied to the fluctuation in token price (deltaTokenPrice)\n     * Dyb is a discount rate as a proportion (that is a percentage in its decimal form) applied to the fluctuation of the treasury yield (deltaTreasuryYield)\n     * Drb, Dyb, deltaTokenPrice and deltaTreasuryYield are expressed as proportions (that is, they are a percentages in decimal form), with 9 decimals\n     */\n    function marketPrice(uint256 _id) public view override returns (uint256) {\n        IBondCalculator theoBondingCalculator = ITreasury(NoteKeeper.treasury).getTheoBondingCalculator();\n        if (address(theoBondingCalculator) == address(0)) {\n            revert(\"No bonding calculator\");\n        }\n        uint8 quoteTokenDecimals = IERC20Metadata(address(markets[_id].quoteToken)).decimals();\n        return\n            ((10**18 / (theoBondingCalculator.valuation(address(markets[_id].quoteToken), 10**quoteTokenDecimals))) *\n                (10**9 - bondRateVariable(_id))) / 10**9;\n    }\n\n    /**\n     * @notice             payout due for amount of quote tokens\n     * @dev                accounts for debt and control variable decay so it is up to date\n     * @param _amount      amount of quote tokens to spend\n     * @param _id          ID of market\n     * @return             amount of THEO to be paid in THEO decimals\n     *\n     * @dev 1e18 = theo decimals (9) + market price decimals (9)\n     */\n    function payoutFor(uint256 _amount, uint256 _id) external view override returns (uint256) {\n        Metadata memory meta = metadata[_id];\n        return (_amount * 1e18) / marketPrice(_id) / 10**meta.quoteDecimals;\n    }\n\n    /**\n     * @notice             calculate debt factoring in decay\n     * @dev                accounts for debt decay since last deposit\n     * @param _id          ID of market\n     * @return             current debt for market in THEO decimals\n     */\n    function currentDebt(uint256 _id) external view override returns (uint256) {\n        return markets[_id].totalDebt - debtDecay(_id);\n    }\n\n    /**\n     * @notice             amount of debt to decay from total debt for market ID\n     * @param _id          ID of market\n     * @return             amount of debt to decay\n     */\n    function debtDecay(uint256 _id) public view override returns (uint64) {\n        Metadata memory meta = metadata[_id];\n\n        uint256 secondsSince = block.timestamp - meta.lastDecay;\n\n        return uint64((markets[_id].totalDebt * secondsSince) / meta.length);\n    }\n\n    /**\n     * @notice             is a given market accepting deposits\n     * @param _id          ID of market\n     */\n    function isLive(uint256 _id) public view override returns (bool) {\n        return (markets[_id].capacity != 0 && terms[_id].conclusion > block.timestamp);\n    }\n\n    /**\n     * @notice returns an array of all active market IDs\n     */\n    function liveMarkets() external view override returns (uint256[] memory) {\n        uint256 num;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) {\n                ids[nonce] = i;\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /**\n     * @notice             returns an array of all active market IDs for a given quote token\n     * @param _token       quote token to check for\n     */\n    function liveMarketsFor(address _token) external view override returns (uint256[] memory) {\n        uint256[] memory mkts = marketsForQuote[_token];\n        uint256 num;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) {\n                ids[nonce] = mkts[i];\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /**\n     * @notice returns an array of market IDs for historical analysis\n     */\n    function getMarkets() external view override returns (uint256[] memory) {\n        uint256[] memory ids = new uint256[](markets.length);\n        for (uint256 i = 0; i < markets.length; i++) {\n                ids[i] = i;\n        }\n        return ids;\n    }\n\n    /**\n     * @notice             returns an array of all market IDs for a given quote token\n     * @param _token       quote token to check for\n     */\n    function getMarketsFor(address _token) external view override returns (uint256[] memory) {\n        uint256[] memory mkts = marketsForQuote[_token];\n        uint256[] memory ids = new uint256[](mkts.length);\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            ids[i] = mkts[i];\n        }\n        return ids;\n    }\n}\n"
    },
    "src/Interfaces/ITokenDebt.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface ITokenDebt is IERC20 {\n    function changeDebt(\n        uint256 amount,\n        address debtor,\n        bool add\n    ) external;\n\n    function debtBalances(address _address) external view returns (uint256);\n}\n"
    },
    "src/Interfaces/IFounderVesting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IFounderVesting {\n    event PayeeAdded(address account, uint256 shares);\n    event ERC20PaymentReleased(IERC20 indexed token, address to, uint256 amount);\n    event PaymentReceived(address from, uint256 amount);\n    event InitialMint(uint256 amount);\n\n    function getTotalShares() external view returns (uint256);\n\n    function getTotalReleased(IERC20 token) external view returns (uint256);\n\n    function getShares(address account) external view returns (uint256);\n\n    function getReleased(IERC20 token, address account) external view returns (uint256);\n\n    function release(IERC20 token) external;\n\n    function releaseAmount(IERC20 token, uint256 amount) external;\n\n    function getReleasable(IERC20 token, address account) external view returns (uint256);\n}\n"
    },
    "src/Theopetra/TheopetraAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"../Interfaces/ITheopetraAuthority.sol\";\nimport \"../Types/TheopetraAccessControlled.sol\";\n\ncontract TheopetraAuthority is ITheopetraAuthority, TheopetraAccessControlled {\n    /* ========== STATE VARIABLES ========== */\n\n    address public override governor;\n\n    address public override guardian;\n\n    address public override policy;\n\n    address public override manager;\n\n    address public override vault;\n\n    address public override whitelistSigner;\n\n    address public newGovernor;\n\n    address public newGuardian;\n\n    address public newPolicy;\n\n    address public newManager;\n\n    address public newVault;\n\n    address public newWhitelistSigner;\n\n    string private constant REQUIRE_ERROR = \"Address cannot be zero address\";\n\n    /* ========== Constructor ========== */\n\n    constructor(\n        address _governor,\n        address _guardian,\n        address _policy,\n        address _manager,\n        address _vault,\n        address _whitelistSigner\n    ) TheopetraAccessControlled(ITheopetraAuthority(address(this))) {\n        require(_governor != address(0), REQUIRE_ERROR);\n        governor = _governor;\n        emit GovernorPushed(address(0), governor, true);\n        require(_guardian != address(0), REQUIRE_ERROR);\n        guardian = _guardian;\n        emit GuardianPushed(address(0), guardian, true);\n        require(_policy != address(0), REQUIRE_ERROR);\n        policy = _policy;\n        emit PolicyPushed(address(0), policy, true);\n        require(_manager != address(0), REQUIRE_ERROR);\n        manager = _manager;\n        emit ManagerPushed(address(0), manager, true);\n        require(_vault != address(0), REQUIRE_ERROR);\n        vault = _vault;\n        emit VaultPushed(address(0), vault, true);\n        require(_whitelistSigner != address(0), REQUIRE_ERROR);\n        whitelistSigner = _whitelistSigner;\n        emit SignerPushed(address(0), whitelistSigner, true);\n    }\n\n    /* ========== GOV ONLY ========== */\n\n    function pushGovernor(address _newGovernor, bool _effectiveImmediately) external onlyGovernor {\n        require(_newGovernor != address(0), REQUIRE_ERROR);\n        if (_effectiveImmediately) governor = _newGovernor;\n        newGovernor = _newGovernor;\n        emit GovernorPushed(governor, newGovernor, _effectiveImmediately);\n    }\n\n    function pushGuardian(address _newGuardian, bool _effectiveImmediately) external onlyGovernor {\n        require(_newGuardian != address(0), REQUIRE_ERROR);\n        if (_effectiveImmediately) guardian = _newGuardian;\n        newGuardian = _newGuardian;\n        emit GuardianPushed(guardian, newGuardian, _effectiveImmediately);\n    }\n\n    function pushPolicy(address _newPolicy, bool _effectiveImmediately) external onlyGovernor {\n        require(_newPolicy != address(0), REQUIRE_ERROR);\n        if (_effectiveImmediately) policy = _newPolicy;\n        newPolicy = _newPolicy;\n        emit PolicyPushed(policy, newPolicy, _effectiveImmediately);\n    }\n\n    function pushManager(address _newManager, bool _effectiveImmediately) external onlyGovernor {\n        require(_newManager != address(0), REQUIRE_ERROR);\n        if (_effectiveImmediately) manager = _newManager;\n        newManager = _newManager;\n        emit ManagerPushed(manager, newManager, _effectiveImmediately);\n    }\n\n    function pushVault(address _newVault, bool _effectiveImmediately) external onlyGovernor {\n        require(_newVault != address(0), REQUIRE_ERROR);\n        if (_effectiveImmediately) vault = _newVault;\n        newVault = _newVault;\n        emit VaultPushed(vault, newVault, _effectiveImmediately);\n    }\n\n    function pushWhitelistSigner(address _newWhitelistSigner, bool _effectiveImmediately) external onlyGovernor {\n        require(_newWhitelistSigner != address(0), REQUIRE_ERROR);\n        if (_effectiveImmediately) whitelistSigner = _newWhitelistSigner;\n        newWhitelistSigner = _newWhitelistSigner;\n        emit SignerPushed(whitelistSigner, newWhitelistSigner, _effectiveImmediately);\n    }\n\n    /* ========== PENDING ROLE ONLY ========== */\n\n    function pullGovernor() external {\n        require(msg.sender == newGovernor, \"!newGovernor\");\n        emit GovernorPulled(governor, newGovernor);\n        governor = newGovernor;\n    }\n\n    function pullGuardian() external {\n        require(msg.sender == newGuardian, \"!newGuard\");\n        emit GuardianPulled(guardian, newGuardian);\n        guardian = newGuardian;\n    }\n\n    function pullPolicy() external {\n        require(msg.sender == newPolicy, \"!newPolicy\");\n        emit PolicyPulled(policy, newPolicy);\n        policy = newPolicy;\n    }\n\n    function pullManager() external {\n        require(msg.sender == newManager, \"!newManager\");\n        emit ManagerPulled(manager, newManager);\n        manager = newManager;\n    }\n\n    function pullVault() external {\n        require(msg.sender == newVault, \"!newVault\");\n        emit VaultPulled(vault, newVault);\n        vault = newVault;\n    }\n\n    function pullWhitelistSigner() external {\n        require(msg.sender == newWhitelistSigner, \"!newWhitelistSigner\");\n        emit SignerPulled(whitelistSigner, newWhitelistSigner);\n        whitelistSigner = newWhitelistSigner;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}